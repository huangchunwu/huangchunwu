<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从分布式事务理论，总结途牛火车票的解决方案</title>
      <link href="/2019/05/22/%E4%BB%8E%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%90%86%E8%AE%BA%EF%BC%8C%E6%80%BB%E7%BB%93%E9%80%94%E7%89%9B%E7%81%AB%E8%BD%A6%E7%A5%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2019/05/22/%E4%BB%8E%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%90%86%E8%AE%BA%EF%BC%8C%E6%80%BB%E7%BB%93%E9%80%94%E7%89%9B%E7%81%AB%E8%BD%A6%E7%A5%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>为解决单机系统的性能瓶颈，无论我们根据业务垂直拆分系统，还是水平分库分表，都会面临分布式事务的问题。解决此类分布式事务的场景，业内已经提出了一致性原理，如数据库单机的ACID，到后面提出的CAP和BASE定理，继而提出了一致性协议，如2PC,3PC,TCC，最后总结出实现最终一致性的方案。</p><ul><li>查询模式</li><li>补偿模式</li><li>异步确保模式</li><li>定期校对模式</li><li>支持事务的MQ</li></ul><p>那么我做了三年的途牛火车票系统采用的是什么解决方案呢？我们用的也是业界常用的<em>异步确保模式</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">异步确保模式核心理论是  将分布式事务转成本地事务处理，具体做法就是在每个业务系统维护一个本地消息记录表，</span><br><span class="line">每次发起请求，记录下请求消息状态，也就是将业务数据与消息表放在一个数据库事务中提交，</span><br><span class="line">系统之间可以使用MQ来传递消息，如果消费失败，或者消息没有发送出去，则通过消息表进行补偿。</span><br></pre></td></tr></table></figure><p><img src="/images/分布式事务.png" alt="分布式事务"></p><p>异步确保模式的弊端就是维护了一份冗余的消息表，需要渗透到业务代码，不过先人也为我们考虑好了解决方案，这一块对消息表的操作已经被封装到rpc客户端的底层代码维护 ，业务系统无需要关心这块的处理。</p><h2 id="途牛火车票的实践"><a href="#途牛火车票的实践" class="headerlink" title="途牛火车票的实践"></a>途牛火车票的实践</h2><p>途牛火车票系统之间，每个系统都有一个请求日志表，系统之间本质是http作为通信协议，底层封装了tsp的客户端请求工具，分布式事务是靠业务方自己实现本地消息表的方案，<br>比如我负责的订单系统，占位，出票，退票，都有记录系统之间的日志表，然后通过日志表的状态进行选择重试或者之间结束流程，以确保系统的最终一致性。<br>比如有一堆订单卡在中间状态，比如占位中，如果消息表没有记录，或者是同步没有反馈，又或者是同步反馈失败，订单系统作为上游系统直接对客失败处理。</p><p>这样的系统设计还存在哪些优点与缺点？</p><ol><li>生产者/消费者的消息持久化，防止消息丢失</li><li>消息表的定期清理，防止数据量过多影响查询性能。</li><li>业务数据与消费发送MQ要在一个事务内执行，确保消息的可靠性。</li><li>不支持回滚，依托BASE理论，保证最终一致性</li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可以暂停的线程池</title>
      <link href="/2019/05/21/%E5%8F%AF%E4%BB%A5%E6%9A%82%E5%81%9C%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2019/05/21/%E5%8F%AF%E4%BB%A5%E6%9A%82%E5%81%9C%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>问渠那得清如许，为有源头活水来</p></blockquote><p>这段时间没有更新博客了，不是因为找到工作了而繁忙了，也不是在忙于找工作，而是趁着有空在家带娃了,没有输入哪来的输出。面试的时候最喜欢问线程池了，我遇到的题目有：</p><ul><li>线程池的工作原理</li><li>Executors 默认的队列为啥没有用arrayBlockingQueue</li><li>如何实现将任务不塞入队列中，直接用线工作线程处理</li><li>如何暂停线程池中的工作线程</li></ul><h2 id="如何实现暂停线程池的工作线程"><a href="#如何实现暂停线程池的工作线程" class="headerlink" title="如何实现暂停线程池的工作线程"></a>如何实现暂停线程池的工作线程</h2><p>其实这个在线程池源码里面有个例子，这里改造了一下，通过命令控制台输入命令控制线程池。原理是：<br>通过重载线程池提供的beforeExecute（），用lock+condition的wait（）使得工作线程暂停。另外提供一个恢复方法，使用的是lock+condition的signalAll唤醒暂停的工作线程。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PauseThreadPool</span> <span class="title">extends</span> <span class="title">ThreadPoolExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> boolean isPaused;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock pauseLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition unpaused = pauseLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PauseThreadPool</span>(<span class="params"><span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue</span>)</span> &#123;</span><br><span class="line">        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池执行任务之前</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span>(<span class="params">Thread t, Runnable r</span>)</span> &#123;</span><br><span class="line">        pauseLock.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isPaused) &#123;</span><br><span class="line">                unpaused.<span class="keyword">await</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            pauseLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//暂停工作线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        pauseLock.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isPaused = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            pauseLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//恢复工作线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        pauseLock.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isPaused = <span class="literal">false</span>;</span><br><span class="line">            unpaused.signalAll();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            pauseLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池执行任务之前</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span>(<span class="params">Runnable r, Throwable t</span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"afterExecute  task:"</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池终止时候调用</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"terminated  task:"</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        PauseThreadPool pool = <span class="keyword">new</span> PauseThreadPool(<span class="number">5</span>, <span class="number">10</span>, <span class="number">30</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.print(<span class="string">"Enter a char :"</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                Scanner sc = <span class="keyword">new</span> Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">                <span class="keyword">int</span> val = sc.nextInt();</span><br><span class="line">                <span class="keyword">if</span> (val == <span class="number">13</span> || val == <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (val == <span class="number">1</span>) &#123;<span class="comment">//命令行输入1，暂停</span></span><br><span class="line">                    pool.pause();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val == <span class="number">2</span>) &#123;<span class="comment">//输入2 恢复</span></span><br><span class="line">                    pool.resume();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val == <span class="number">0</span>) &#123;<span class="comment">// 提交任务</span></span><br><span class="line">                    pool.submit(<span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Object <span class="title">call</span>(<span class="params"></span>) throws Exception</span> &#123;</span><br><span class="line">                            System.<span class="keyword">out</span>.println(<span class="string">"start  task:"</span> + Thread.currentThread().getName());</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (val == <span class="number">3</span>)&#123;<span class="comment">//关闭线程池</span></span><br><span class="line">                    pool.shutdown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何写一个程序频繁的FULL GC</title>
      <link href="/2019/05/10/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E9%A2%91%E7%B9%81%E7%9A%84FULL-GC/"/>
      <url>/2019/05/10/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E9%A2%91%E7%B9%81%E7%9A%84FULL-GC/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GcExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB=<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*_1MB];</span><br><span class="line">            b=<span class="keyword">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> System.gc()源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Runtime.getRuntime().gc();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>显示的使用 System.gc()，会导致频繁full gc，这个方法可以在禁用掉<br>在vm options加入<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:+DisableExplicitGC</span></span><br></pre></td></tr></table></figure></p><p>那么System.gc()有什么作用吗？<br>在使用堆外内存的时候，会配合使用。<br>通过-XX:MaxDirectMemorySize来指定最大的堆外内存大小，当使用达到了阈值的时候将调用System.gc来做一次full gc，以此来回收掉没有被使用的堆外内存。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap的源码解析</title>
      <link href="/2019/05/09/HashMap%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/05/09/HashMap%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近忙着面试，把学习的东西，通过博客沉淀下来，一方面加深自己的理解，另方面方便以后自己再次复习。HashMap 是面试喜欢问的问题，那么HashMap的原理是什么呢？</p><hr><h2 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h2><p>HashMap的数据结构是 数组+链表。 </p><p>数组默认大小等于16，这个数组也称Hash桶。<br>链表是存放Hash冲突的entry对象的。这里该提到数据结构的hash冲突的几种解决方法，hashMap采用的是链地址法。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hash冲突解决的常见办法：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>开放定址法</span><br><span class="line"><span class="number">2.</span>再哈希法</span><br><span class="line"><span class="number">3.</span>链地址法</span><br><span class="line"><span class="number">4.</span>建立公共溢出区</span><br></pre></td></tr></table></figure><h2 id="怎么处理hash冲突"><a href="#怎么处理hash冲突" class="headerlink" title="怎么处理hash冲突"></a>怎么处理hash冲突</h2><p>当我们向HashMap put一个KV时候，先对KEY做hashCode,为了减少hash冲撞的机会，还经过了扰动函数计算，让hash的更均匀。<strong>jdk7在这里扰动了4次而JDK8，做了简化。</strong></p><p>计算出来的hashcode与数组的容量进行与运算代替模运算，  因为hash桶只有16个，因此出现hash冲撞的可能性会增大。通过位运算后的值即为key-value存放的位置。当出现hash冲撞的时候，hashmap会将新进来的值塞进链表的尾部，当hash冲撞的机会高的时候，链表的长度也会增大，我们知道链表的查询的时间复杂度是N，jdk8在这里做了改进，具体为当链表长度大于8的时候，会转为红黑树，红黑树的特点是平衡二叉树，查询的时间复杂度是logn. </p><h2 id="怎么扩容呢？"><a href="#怎么扩容呢？" class="headerlink" title="怎么扩容呢？"></a>怎么扩容呢？</h2><p>当hashMap的数组容量超过自己的0.75的时候，也就是默认容量16*0.75=12个的时候，则会进行一次扩容，这里的0.75就是<strong>加载因子</strong>，12就是<strong>阈值</strong>。<br>扩容的复杂度很高，先扩容，再移动旧的数组的值到新的数组去，性能会很低,所以我们要减少hashmap的扩容次数，初始化的时候，尽量设置初始容量。接下来，我们看看扩容的过程，先复制一个原来2倍容量的数组，然后重新计算key<br>的hash值，将旧数据搬到新的数组中去，这时候如果有新的数据进来也会插入尾部，会出现争抢位置的并发问题，而HashMap是线程不安全的。</p><h2 id="hashMap线程安全的实现方式"><a href="#hashMap线程安全的实现方式" class="headerlink" title="hashMap线程安全的实现方式"></a>hashMap线程安全的实现方式</h2><p>线程安全的hashMap，使用concurrentHashMap,这个类是基于分段锁。实现HashMap线程安全还有另外一种方法，Collections.synchronized(new HashMap()),但是这种是全部方法加锁的，跟hashtable一样，锁粒度大，效率不好。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring多个AOP多注解执行顺序是怎么样的</title>
      <link href="/2019/05/07/Spring%E5%A4%9A%E4%B8%AAAOP%E5%A4%9A%E6%B3%A8%E8%A7%A3%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84/"/>
      <url>/2019/05/07/Spring%E5%A4%9A%E4%B8%AAAOP%E5%A4%9A%E6%B3%A8%E8%A7%A3%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>今天去了杉德面试，整体感觉还好。就spring AOP，对方问了下AOP事务失效的场景有哪些？幸亏之前做了一篇文章，刚好用到了这块的知识<a href="https://huangchunwu.github.io/2018/12/16/aop/">spring声明式事务失效的分析过程</a>。另外还问了多个AOP的执行顺序是怎么样的，比如一个方法，有二个AOP注解，那么这2个注解的before，after方法的执行顺序是什么？我脑子是空白的，只是拼着三寸不烂之舌，“这个我平时没注意过，不过是我遇到的话，我会结合当时的业务需求，看执行顺序是否影响再做下一步处理”。回来网上查了下资料，原来答案这样简单，实现order接口，order越小的先执行，当然越小的order的AOP最后才能完成任务。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Aspect</span></span><br><span class="line"><span class="variable">@Slf4j</span></span><br><span class="line">public class MessageQueueAopAspect1 implements Ordered&#123;<span class="variable">@Override</span></span><br><span class="line">public int getOrder() &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="selector-tag">return</span> <span class="selector-tag">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>order越小越是最先执行，也是最后一个执行完成。可以借助下面这张图理解。<br><img src="/images/aop.png" alt="我的头像"></p><p>由此得出：spring aop就是一个同心圆，要执行的方法为圆心，最外层的order最小。从最外层按照AOP1、AOP2的顺序依次执行doAround方法，doBefore方法。然后执行method方法，最后按照AOP2、AOP1的顺序依次执行doAfter、doAfterReturn方法。也就是说对多个AOP来说，先before的，一定后after。</p><pre><code>如果我们要在同一个方法事务提交后执行自己的AOP，那么把事务的AOP order设置为2，自己的AOP order设置为1，然后在doAfterReturn里边处理自己的业务逻辑。</code></pre><p> 附录<br> <a href="https://blog.csdn.net/qqxhwwqwq/article/details/51678595#" target="_blank" rel="noopener">spring多个AOP执行先后顺序</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分库分表技术储备</title>
      <link href="/2019/05/06/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%8A%80%E6%9C%AF%E5%82%A8%E5%A4%87/"/>
      <url>/2019/05/06/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%8A%80%E6%9C%AF%E5%82%A8%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>数据库，很容易成为应用系统的瓶颈。单机数据库的资源与处理能力有限，在高并发的分布式服务中，可采取分库分表突破单机局限。其实，在除了少数的公司流量大，大部分用不上分库分表，主从读写分离这样的架构已经可以满足业务的需求了，可是偏偏面试的时候，mains面试官喜欢问些这些逼格的玩意，我也特意琢磨了一下，并且记录下来技术方案，期待在以后的工作中，尽快落地。</p><h2 id="是否需要分库分表？"><a href="#是否需要分库分表？" class="headerlink" title="是否需要分库分表？"></a>是否需要分库分表？</h2><p>当我们的表记录不超过百万级，不需要分库、分表。如果此时DB性能有问题，可以通过优化SQL，优化索引，增加DB服务器CPU/内存，读写分离。</p><p>我们做数据库切分设计的时候，优先垂直切分，读写分离，如果还不行的话，不得不才水平分库分表，切记过度设计。</p><h2 id="分库分表的方案"><a href="#分库分表的方案" class="headerlink" title="分库分表的方案"></a>分库分表的方案</h2><ul><li><p>垂直拆分<br>垂直分库：<br>如今微服务盛行，根据业务来划分系统，我们也跟着业务来划分数据库，比如订单库，用户库，这样解决了单机DB服务器的局限。缺点是做查询，聚合数据的时候，需要通过系统之间的接口，聚拢数据再做处理，系统复杂度高。<br>垂直分表：<br>适合在做表设计的时候，表字段比较多，将一些不常用的，数据较大长度过长的字段拆到扩展表去。缺点就是不适合在运行中系统做拆分。</p></li><li><p>水平拆分<br>水平分表：<br>当表数据超过百万了，那么我们可以采取根据ID的hash到不同分表，但是还是在同个库里面做拆分。缺点就是还是没有摆脱单机的资源局限，所以一般不推荐。</p></li><li><p>水平分库分表：<br>上面的方案，还是支撑不了我们的业务数据，我们才会采用，将单表的数据量切分到不同的服务器上，每台服务器都有相应的库与表，只是数据集合不同。</p></li></ul><h2 id="水平分库分表的切分策略"><a href="#水平分库分表的切分策略" class="headerlink" title="水平分库分表的切分策略"></a>水平分库分表的切分策略</h2><ul><li>根据ID或者时间范围切分，比如1-100000 A1库，100001-200000 A2库…</li><li>根据ID/订单号的HASH，比如有4台数据库，%4=1分给A1，%4=2分给A2，%4=3分给A3，%4=0 分给4。</li><li>根据时间切分，比如2018年的在A1库，2019年的在A2库。这样导致db负载分布不均匀，老数据比较访问量少，这样浪费了系统资源。</li></ul><h2 id="水平分库分表的成熟产品"><a href="#水平分库分表的成熟产品" class="headerlink" title="水平分库分表的成熟产品"></a>水平分库分表的成熟产品</h2><p>分2种，一个代理模式的有corbar,Mycat,Sharding-jdbc<br>另一种非代理的TDDL 阿里的需要配合Diamond，Mysql官方的Fabric</p><h2 id="分库分表面临的问题"><a href="#分库分表面临的问题" class="headerlink" title="分库分表面临的问题"></a>分库分表面临的问题</h2><ul><li><p>分布式事务<br>分布式事务，有现成的产品支持，比如Jotm、Automikos 等来实现，两者均支持 spring 事务整合，但是在高性能高并发系统，不推荐使用。</p></li><li><p>跨库JOIN，orderby，group by<br>解决方案：<br>数据库层面，冗余字段，加个查询常用的全量表。<br>应用层面，通过系统间组合数据，再做相应的数据处理。</p></li><li><p>扩容带来的数据迁移</p><p><strong>夜间停机</strong><br>影响业务运行，不过一般夜间执行，夜间在线的活跃用户超过1000的用户仅有几家吧。<br><strong>双写法</strong><br>在前面的一篇文章提到过<a href="https://huangchunwu.github.io/2019/04/26/%E9%9D%A2%E8%AF%95/">如何平滑数据迁移不影响服务的可用性</a></p></li></ul><blockquote><p> 总结下来是三步：<br>准备新库，加入双写代码<br>迁移历史数据<br>校验新旧库数据一致性，平滑切到新库。</p></blockquote><p>如何校验数据一致性？<br>校验新旧库的数据量是否一样<br>取新旧库的1-50之间数据然后MD后比对，再取51-100的数据比对，哪里不一致做个标记，再次同步。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><p> <a href="https://kefeng.wang/2018/07/22/mysql-sharding/" target="_blank" rel="noopener">MySQL 分库分表及其平滑扩容方案</a><br> <a href="http://zhuanlan.51cto.com/art/201702/530555.htm" target="_blank" rel="noopener">58沈剑：数据库秒级平滑扩容架构方案</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分库分表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发下，redis热点KEY的解决方案</title>
      <link href="/2019/05/05/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8Bredis%E7%83%AD%E7%82%B9KEY%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2019/05/05/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8Bredis%E7%83%AD%E7%82%B9KEY%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在高并发系统中，我们将多个KEY数据分片，hash均衡分布在redis集群中，如果遇到活动，或者明星的热点新闻，那这台存有热点的KEY的redis实例，遇到百万的流量，这台机器的网卡也恐怕撑不住了，那么redis基本就瘫痪了，服务器抓取不到redis的数据，直接去请求DB，那么db也就遭殃了，于是被领导拖到小黑屋…..<br>那么，有什么解决方案呢？</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>主要分2步</p><blockquote><ol><li>动态统计计算出KEY的请求次数，识别为热点数据</li><li>识别出热点数据，通过zookeeper通知服务器更新为本地缓存，Ehcache,又或者是static map，当然要注意防止本地内存溢出。</li></ol></blockquote><p>如何动态识别KEY为热点数据？</p><ul><li><p>客户端   </p><p>redis客户端发起redis请求的时候，为每个KEY计数,存在本地缓存，或数据库</p></li><li><p>代理层<br>redis集群架构加一层，Twemproxy、Codis代理，由代理统计。（推荐）</p></li><li><p>服务端<br>利用redis的monitor命令</p></li><li><p>机器TCP流量    </p></li></ul><p>参考资料<br>《Redis开发与运维》<br><a href="https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&amp;mid=2247484401&amp;idx=1&amp;sn=823cffa4a1aa73335bdfb7c02e8c85f0&amp;chksm=fba6ebf2ccd162e422b1b496f5790ebdf7f6d11adb8d2e00957ca371dcca0514a3fde09af521&amp;mpshare=1&amp;scene=23&amp;srcid=#rd" target="_blank" rel="noopener">如果20万用户同时访问一个热点缓存，如何优化你的缓存架构？</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现缓存击穿，只允许一条线程去DB更新数据</title>
      <link href="/2019/05/03/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/"/>
      <url>/2019/05/03/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>使用redis控制缓存的时候，弊端是太依赖于网络与redis服务的稳定性。在高并发的场景下，如果某个KEY过期了，会有很多的GET该KEY的请求，直接会去查询DB，甚至导致DB瘫痪，那么有啥解决方案呢？</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>利用互斥锁，只允许一个线程去DB查询，其他线程等待一段时间重试，当查询DB反馈结果后重新设置到缓存中，那么其他线程直接走缓存就可以了。这里的锁，可以选分布式锁，比如zookeeper锁，JVM锁,redis的setNx互斥锁。</p><ol><li>ZooKeeper锁的弊端是，堵塞锁，即只要有线程已经获得锁，其他想获取锁的线程都会等待锁释放，影响QPS。</li><li>JVM锁，可以用Lock,Synchronized。推荐的用法是《JAVA并发编程的艺术》提到的concurrentHashMap与futureTask，代码如下<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class CacheUtil &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;<span class="keyword">Object</span>, Future&lt;<span class="keyword">String</span>&gt;&gt; taskCache =</span><br><span class="line">            <span class="keyword">new</span> ConcurrentHashMap&lt;<span class="keyword">Object</span>, Future&lt;<span class="keyword">String</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> executionTask(<span class="keyword">final</span> <span class="keyword">String</span> taskName)</span><br><span class="line">            <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Future&lt;<span class="keyword">String</span>&gt; future = taskCache.<span class="built_in">get</span>(taskName);</span><br><span class="line">            <span class="keyword">if</span> (future == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Callable&lt;<span class="keyword">String</span>&gt; task = <span class="keyword">new</span> Callable&lt;<span class="keyword">String</span>&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">String</span> call() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">                        <span class="keyword">return</span> taskName;<span class="comment">//loadDb</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                FutureTask&lt;<span class="keyword">String</span>&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;<span class="keyword">String</span>&gt;(task);</span><br><span class="line">                future = taskCache.putIfAbsent(taskName, futureTask);</span><br><span class="line">                <span class="keyword">if</span> (future == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    future = futureTask;</span><br><span class="line">                    futureTask.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> future.<span class="built_in">get</span>();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                taskCache.remove(taskName, future);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>弊端就是只能限制同个进程的缓存更新。</p><ol start="3"><li>redis分布式锁。值得注意的是低版本的redis，setNx与expire是二步操作，不能保证原子性，下面提供一个高版本的redis,setNx可以设置过期时间的。</li></ol><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> <span class="built_in">get</span>(<span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="keyword">String</span> value = redis.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">//代表缓存值过期</span></span><br><span class="line">    <span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line">        <span class="keyword">String</span> keynx = <span class="built_in">key</span>.<span class="built_in">concat</span>(<span class="string">":nx"</span>);</span><br><span class="line">        <span class="keyword">if</span> (redis.setnx(keynx, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123; <span class="comment">//代表设置成功</span></span><br><span class="line">            value = db.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">            redis.<span class="built_in">set</span>(<span class="built_in">key</span>, value, expire_secs);</span><br><span class="line">            redis.del(keynx);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">        sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="built_in">get</span>(<span class="built_in">key</span>); <span class="comment">//重试</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用协程代替线程,减少上下文切换</title>
      <link href="/2019/05/02/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/"/>
      <url>/2019/05/02/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在开发工作中，遇到一些串行处理比较耗时的任务，我会想到用多线程，切片并行执行，已减少请求响应时间，提高吞吐量。可是，开辟线程也是需要消耗系统内存的，一个线程的线程栈，JVM默认配置1M左右，线程栈的内存的上限 只受操作系统的内存限制，所以线程创建过多，会在JVM的LOG日志看到这一行<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: unable to <span class="keyword">create</span> <span class="keyword">new</span> <span class="keyword">native</span> <span class="keyword">thread</span></span><br></pre></td></tr></table></figure></p><p>，通常我们使用的线程池来管理和监控线程,使用线程池注意的地方参考<a href="https://huangchunwu.github.io/2019/04/30/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%B9%E6%98%93%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84%E5%9C%B0%E6%96%B9/">线程池容易被忽略的地方</a>。</p><p>话说回来，我们创建线程，就能提高性能吗？创建线程数一般根据CPU的个数来设置的。**一个CPU只会同时支持一个线程运行，CPU根据分配的时间片（单位几十MS）运行该线程，到了这个时间片后，有二种情况：</p><ol><li>这个线程任务执行完了，则释放CPU</li><li>这个线程的任务还没有执行完，则CPU也会强行释放服务其他线程了，并将该线程塞到等待队列等待下次调度，在很短的时间后该线程又获得了CPU调度，CPU根据上次的状态（对应JVM的谈到的程序计数器），继续执行下去，这一个周期叫做上下文切换**，由此可见CPU上下文切换影响线程执行效率。</li></ol><h2 id="如何定量分析上下文切换次数呢？"><a href="#如何定量分析上下文切换次数呢？" class="headerlink" title="如何定量分析上下文切换次数呢？"></a>如何定量分析上下文切换次数呢？</h2><p>Linux提供了性能检测工具，使用<code>vmstat</code>可以测量上下文切换的次数。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@ubuntu</span><span class="symbol">:~</span><span class="comment"># vmstat 2 1</span></span><br></pre></td></tr></table></figure></p><ul><li>第一个参数是采样的时间间隔数，单位是秒</li><li>第二个参数是采样的次数</li></ul><p>运行后有如下参数：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r  <span class="keyword">b </span>  <span class="keyword">swpd </span>  free   <span class="keyword">buff </span> <span class="keyword">cache </span>  si   so    <span class="keyword">bi </span>   <span class="keyword">bo </span>  in   cs us</span><br></pre></td></tr></table></figure></p><blockquote><p>r<br>表示运行队列(就是说多少个进程真的分配到CPU)，当这个值超过了CPU数目，就会出现CPU瓶颈了。如果运行队列过大，表示你的CPU很繁忙，一般会造成CPU使用率很高。</p></blockquote><blockquote><p>cs<br>每秒上下文切换次数，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目，上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。</p></blockquote><h2 id="那么如何减少上下文切换呢？"><a href="#那么如何减少上下文切换呢？" class="headerlink" title="那么如何减少上下文切换呢？"></a>那么如何减少上下文切换呢？</h2><ul><li>可以想到的是，增加CPU，当然增加了硬件的成本，老板不同意的。</li><li>另一个容易就是想到的，减少线程数，这个只能视业务而定。</li><li>再一个就是无锁编程，锁会增大线程上下文切换的次数。</li><li>还有一个该提到的就是CAS，JDK里原子类和并发包都有应用。</li><li><strong>最后提到的是，用<code>协程</code>代替线程</strong>。</li></ul><h2 id="那么什么是协程呢？"><a href="#那么什么是协程呢？" class="headerlink" title="那么什么是协程呢？"></a>那么什么是协程呢？</h2><p>协程跟线程的用法相似，对于我们JAVA党不熟悉，但在golang,kotlin 1.30，python:都有原生的支持了。具体用法参考<a href="http://www.apkbus.com/blog-942559-79349.html" target="_blank" rel="noopener">聊一聊 Java-协程 那些事</a>,我目前的水平还达不到解说，值得提的是如下几点：<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于那些需要CPU长时间计算的代码，很少遇到阻塞的时候，就应该首选<span class="keyword">thread</span>。</span><br><span class="line">当代码经常会被等待其它资源的阻塞的时候，就应该使用协程</span><br></pre></td></tr></table></figure></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://wangchangchung.github.io/2017/05/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94CPU%E8%B0%83%E5%BA%A6/" target="_blank" rel="noopener">操作系统——CPU调度</a><br><a href="https://juejin.im/post/5c37377351882525ec200f9e" target="_blank" rel="noopener">从 synchronized 到 CAS 和 AQS - 彻底弄懂 Java 各种并发锁</a><br><a href="https://www.cnblogs.com/ggjucheng/archive/2012/01/05/2312625.html" target="_blank" rel="noopener">Linux vmstat命令实战详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池容易被忽略的地方</title>
      <link href="/2019/04/30/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%B9%E6%98%93%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84%E5%9C%B0%E6%96%B9/"/>
      <url>/2019/04/30/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%B9%E6%98%93%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84%E5%9C%B0%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么用线程池？"><a href="#为什么用线程池？" class="headerlink" title="为什么用线程池？"></a>为什么用线程池？</h2><ul><li>节约省资源<br>创建线程有损耗，销毁线程也有损耗</li><li>执行效率高<br>充分利用多核CPU，并行处理。处理任务，不需要等待线程创建的过程立即执行。</li><li>管理线程<br>线程是操作系统稀缺的资源，不可滥用。线程池可以做到统一分配，调优和监控。</li></ul><h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><p>任务请求过来，当前线程数小于核心线程池线程数，创建线程执行；<br>当前线程数大于等于核心线程数，则放到队列等待空闲线程处理。<br>当任务队列满了，则创建线程，执行任务。<br>当线程池的最大线程数都繁忙，则走拒绝策略。</p><p><strong>注意</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这里有个核心线程池，与线程池的概念</span><br><span class="line">核心线程池的线程没有初始化创建完，而不会用核心线程池空闲线程执行新来的任务，而是优先创建线程</span><br></pre></td></tr></table></figure></p><p><strong>思考</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当线程池当前线程数已经大于核心线程数，这时候线程池也已经空闲了一段时候，非核心线程已经消亡，</span><br><span class="line">这个时候新请求过来一个任务，这时候线程池是新建一个线程处理，还是将线程放入队列中，</span><br><span class="line">又或者用核心线程去处理</span><br></pre></td></tr></table></figure><h2 id="如何优雅关闭线程池"><a href="#如何优雅关闭线程池" class="headerlink" title="如何优雅关闭线程池"></a>如何优雅关闭线程池</h2><p>shutdown与shutdownNow，<strong>都无法保证100%关闭线程池的线程</strong>。<br><strong>shutdownNow将所有工作线程中断，并返回还没完成的任务集</strong><br>isShutDown()  当执行了上面二个命令，则返回true<br>isTerminaed() 判断线程是否全部终止，线程池完美关闭。</p><h2 id="如何合理配置线程池"><a href="#如何合理配置线程池" class="headerlink" title="如何合理配置线程池"></a>如何合理配置线程池</h2><p>根据任务的特性分几个方面：</p><ul><li><p><strong>任务的性质</strong><br>IO密集的任务，2Ncpu 个线程数<br>CPU计算密集的任务，Ncpu+1 个线程数<br>混合型的任务，则看情况，将任务分成IO密集和CPU密集的分别执行，如果二者执行时间相差不大，则没必要。</p></li><li><p><strong>任务的执行的时间长短</strong><br>让执行时间短的先行</p></li><li><strong>任务的优先级</strong><br>使用优先级队列，注意会导致优先级不高的永远不执行。</li><li><strong>任务的依赖性</strong><br>是否依赖其他资源，比如数据库，Redis，第三方。2Ncpu 个线程数执行。</li></ul><h2 id="线程池监控"><a href="#线程池监控" class="headerlink" title="线程池监控"></a>线程池监控</h2><p>可以利用线程池里面提供的参数监控：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池在运行过程中已完成的任务数量，小于或等于taskCount</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池需要执行的任务数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTaskCount</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池的线程数量。如果线程池不销毁的话，</span></span><br><span class="line"><span class="comment"> * 线程池里的线程不会自动销毁,所以这个大小只增不减</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPoolSize</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>重写线程池的beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。</p><p>思考：getPoolSize（）<br>线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁,所以这个大小只增不减。<br>这句话，没那么绝对。线程池中工作线程销毁的条件：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)  参数allowCoreThreadTimeOut为true</span><br><span class="line"><span class="number">2</span>)  该线程在keepAliveTime时间内获取不到任务，即空闲这么长时间</span><br><span class="line"><span class="number">3</span>)  当前线程池大小 &gt; 核心线程池大小corePoolSize</span><br></pre></td></tr></table></figure></p><p>long keepAliveTime<br>该线程池中非核心线程闲置超时时长<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个非核心线程，如果不干活<span class="comment">(闲置状态)</span>的时长超过这个参数所设定的时长，就会被销毁掉</span><br><span class="line">另外默认对非核心线程有效，若想核心线程也适用于这个机制，</span><br><span class="line">可以调用allowCoreThreadTimeOut<span class="comment">()</span>方法。这样的话就没有核心线程这一说了。</span><br></pre></td></tr></table></figure></p><h2 id="线程池的队列"><a href="#线程池的队列" class="headerlink" title="线程池的队列"></a>线程池的队列</h2><p>ArrayBlockingQueue数组有界队列<br>LinkedBlockingQueue链表无界队列  Executors.newFixedThreadPool()<br>PriorityBlockingQueue优先级无界队列<br>SynchronousQueue不保留任务的队列    Executors.newCachedThreadPool<br>DelayQueue 延迟队列</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://zackku.com/java-thread-threadpoolexecutor/" target="_blank" rel="noopener">你真的懂ThreadPoolExecutor线程池技术吗？看了源码你会有全新的认识</a><br><a href="https://juejin.im/post/5c8896be5188257ec828072f#heading-5" target="_blank" rel="noopener">深入理解线程池原理篇</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis incr做接口访问频率的坑</title>
      <link href="/2019/04/29/Redis-incr%E5%81%9A%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AE%E9%A2%91%E7%8E%87%E7%9A%84%E5%9D%91/"/>
      <url>/2019/04/29/Redis-incr%E5%81%9A%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AE%E9%A2%91%E7%8E%87%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在互联网高并发的分布式系统中，我们需要对接口限流，我会用Redis的incr命令，如果是单机的话，用Guava的RateLimiter就可以了。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>INCRBY key increment</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; <span class="keyword">SET</span> page_view <span class="comment">20</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; INCR <span class="comment">page_view</span></span><br><span class="line">(integer) 21</span><br><span class="line"></span><br><span class="line">redis&gt; GET <span class="comment">page_view    #</span> 数字值在<span class="comment"> Redis</span> 中以字符串的形式保存</span><br><span class="line"><span class="string">"21"</span></span><br></pre></td></tr></table></figure><p>这里需要注意的是:<br>为键 key 储存的数字值加上增量 increment 。<br>如果键 key 不存在， 那么键 key 的值会先被初始化为 0 ， 然后再执行 INCRBY 命令。。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">redis</span>&gt; <span class="meta">TTL</span> key</span><br></pre></td></tr></table></figure><p>当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以秒为单位，返回 key 的剩余生存时间。</p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>我实现一个功能，限制一分钟内，接口的访问频率是100次，于是写出如下的代码</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Jedis redis = getRedis();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">Long</span> <span class="keyword">count</span> = redis.incrBy(key, <span class="number">1</span>);</span><br><span class="line">    redis.expire(key,<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">count</span> &gt; maxAllowedTimes) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    redis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里设置KEY过期时间为60s内，KEY由1开始递增，当KEY超过阈值，则请求不给通过，看起来，没有问题。其实这里的问题出在上一篇<a href="https://huangchunwu.github.io/2019/04/28/Redis%E6%89%A7%E8%A1%8Cexpire%E5%91%BD%E4%BB%A4%E5%A4%B1%E8%B4%A5%E5%BC%95%E5%8F%91%E7%9A%84%E5%9D%91/">Redis执行expire命令失败引发的坑</a>提到的，如果redis.expire(key,60)执行失败了，那么KEY就遗留在内存里面，失去了“60s内限流的作用”。</p><p>网上Google了下“Redis 坑”，列举了好几页，redis要慎用啊。<br>比如：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Jedis </span>redis = getRedis()<span class="comment">;</span></span><br><span class="line">try &#123;</span><br><span class="line">    redis<span class="meta">.set</span>(SafeEncoder.encode(key), SafeEncoder.encode(def + <span class="string">""</span>), <span class="string">"nx"</span>.getBytes(),</span><br><span class="line">    <span class="string">"ex"</span>.getBytes(), exp)<span class="comment">;</span></span><br><span class="line">    Long <span class="built_in">count</span> = redis.incrBy(key.getBytes(), val)<span class="comment">;</span></span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    redis.<span class="keyword">close();</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure></p><p>这段代码，如果KEY在失效时间内执行set,发现KEY已经存在，则不设置过期时间，<br>刚好在执行set, incrBy 之间过期了，那么这个KEY就一直存在了。</p><p>还有一位老兄这样写：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = RedisUtils.getJedis();</span><br><span class="line">String requestKey = <span class="keyword">Times</span> + <span class="string">":"</span> + ID + <span class="string">":"</span> + getId();</span><br><span class="line"><span class="keyword">if</span> (jedis.exists(requestKey)) &#123;</span><br><span class="line">    <span class="comment">//如果这里KEY过期</span></span><br><span class="line">jedis.incr(requestKey);</span><br><span class="line">String <span class="keyword">times</span> = jedis.get(requestKey);</span><br><span class="line"><span class="keyword">if</span> (StringUtil.strIsNotEmpty(<span class="keyword">times</span>))&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">Long</span>.parseLong(<span class="keyword">times</span>) &gt; maxAllowedTimes) &#123;</span><br><span class="line">jedis.del(requestKey);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">jedis.set(requestKey, <span class="string">"1"</span>);</span><br><span class="line">jedis.pexpire(requestKey,REQUEST_EXIT_MILLISECONDS);</span><br></pre></td></tr></table></figure><p>如果上述代码在KEY有效期执行，在标注的地方刚好失效，则执行incr，设置KEY为0，永久有效。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>TTL校验过期时间，如果没set expire成功重新重试6次，还是失败，则发给MQ，后续再做处理<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Jedis redis = getRedis()) &#123;</span><br><span class="line">Long count = redis.incrBy(<span class="built_in">key</span>.getBytes(), val);</span><br><span class="line"><span class="keyword">if</span> (count == val) &#123;</span><br><span class="line">             <span class="keyword">try</span>&#123;</span><br><span class="line">                 redis.expire(<span class="built_in">key</span>, <span class="built_in">exp</span>);</span><br><span class="line">              &#125;catche(Exception e)&#123; </span><br><span class="line">                  redis.expire(<span class="built_in">key</span>, <span class="built_in">exp</span>);</span><br><span class="line">              &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                   <span class="keyword">if</span>(redis.ttl(<span class="built_in">key</span>)==<span class="number">-1</span>)&#123;</span><br><span class="line">                       <span class="keyword">try</span>&#123;   </span><br><span class="line">                         redis.expire(<span class="built_in">key</span>, <span class="built_in">exp</span>);</span><br><span class="line">                      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                          sendMQ(<span class="built_in">key</span>);##发送给MQ，接着消费处理</span><br><span class="line">                        &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">              &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis执行expire命令失败引发的坑</title>
      <link href="/2019/04/28/Redis%E6%89%A7%E8%A1%8Cexpire%E5%91%BD%E4%BB%A4%E5%A4%B1%E8%B4%A5%E5%BC%95%E5%8F%91%E7%9A%84%E5%9D%91/"/>
      <url>/2019/04/28/Redis%E6%89%A7%E8%A1%8Cexpire%E5%91%BD%E4%BB%A4%E5%A4%B1%E8%B4%A5%E5%BC%95%E5%8F%91%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在我们做系统开发的时候，遇到高并发的场景，我们对一些数据会直接借助Redis存储，又或者借助Redis实现分布式锁，它带给我们很多的好处，同时我们在使用的时候，会遇到很多的坑，接下来，是我面试的时候遇到的一个问题，我平时一直没意识到。</p><p>给KEY设置过期时间，如下<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">EXPIRE key seconds</span></span><br></pre></td></tr></table></figure></p><p>我们系统Redis通过集群，实现HA，可是也难免会因为网络抖动，又或者Redis达到瓶颈，EXPIRE/DELETE 这样的操作，可能会失败，导致的后果就是Redis残留无效KEY。那么日积月累。。。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ol><li>给定 key 的剩余生存时间</li></ol><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">redis</span>&gt; <span class="meta">TTL</span> key</span><br></pre></td></tr></table></figure><ol start="2"><li>Redis分布式锁</li></ol><p>Redis分布式锁在2.6.12版本之后的实现方式比较简单，只需要使用一个命令即可：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">key</span> <span class="keyword">value</span> [EX seconds] [NX]</span><br></pre></td></tr></table></figure></p><p>这个命令相当于2.6.12之前的setNx和expire两个命令的原子操作命令</p><ol start="3"><li>GETSET key value</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GETSET db mongodb    # 没有旧值，返回 <span class="literal">nil</span></span><br><span class="line">(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">redis&gt; <span class="builtin-name">GET</span> db</span><br><span class="line"><span class="string">"mongodb"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GETSET db redis      # 返回旧值 mongodb</span><br><span class="line"><span class="string">"mongodb"</span></span><br><span class="line"></span><br><span class="line">redis&gt; <span class="builtin-name">GET</span> db</span><br><span class="line"><span class="string">"redis"</span></span><br></pre></td></tr></table></figure><p>将键 key 的值设为 value ， 并返回键 key 在被设置之前的旧值</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>当时，因为知识体系里面没有这个东西，没有答出来。今天回头想想，翻了一下《Redis实战》，里面有提到这个，</p><blockquote><p>为了确保锁在客户端已经崩溃（客户端在执行介于SETNX与EXPIRE之间的时候崩溃是最糟糕的）的情况下仍然能够自动被释放，客户端会在尝试获取锁失败之后，检查锁的超时时间，并为未设置超时时间的锁设置超时时间。</p></blockquote><p>那么如果第二次EXPIRE又失败了，怎么办？<br>我想到的方案是，重试5次，还失败的话，将失败的KEY,放入MQ等待下次消费。</p><h2 id="Redis分布式锁，如果EXPIRE失败，导致死锁"><a href="#Redis分布式锁，如果EXPIRE失败，导致死锁" class="headerlink" title="Redis分布式锁，如果EXPIRE失败，导致死锁"></a>Redis分布式锁，如果EXPIRE失败，导致死锁</h2><p>通过上面，我们也知道了不能依赖EXPIRE让KEY失效。Redis在分布式锁上，更不能依赖EXPIRE释放锁，网上借鉴来的比较稳妥的方法如下</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> booelan <span class="title">getLock</span>(<span class="params">String lockKey</span>)</span> &#123;</span><br><span class="line">    boolean <span class="keyword">lock</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">lock</span>) &#123;</span><br><span class="line">        String expireTime = String.valueOf(System.currentTimeMillis() + <span class="number">5000</span>);</span><br><span class="line">        <span class="comment">// (1)第一个获得锁的线程，将lockKey的值设置为当前时间+5000毫秒，后面会判断，如果5秒之后，获得锁的线程还没有执行完，会忽略之前获得锁的线程，而直接获取锁，所以这个时间需要根据自己业务的执行时间来设置长短。</span></span><br><span class="line">        <span class="keyword">lock</span> = shardedXCommands.setNX(lockKey, expireTime);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">lock</span>) &#123; <span class="comment">// 已经获取了这个锁 直接返回已经获得锁的标识</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">lock</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 没获得锁的线程可以执行到这里：从Redis获取老的时间戳</span></span><br><span class="line">        String oldTimeStr = shardedXCommands.<span class="keyword">get</span>(lockKey);</span><br><span class="line">        <span class="keyword">if</span> (oldTimeStr != <span class="literal">null</span> &amp;&amp; !<span class="string">""</span>.<span class="keyword">equals</span>(oldTimeStr.trim())) &#123;</span><br><span class="line">            Long oldTimeLong = Long.valueOf(oldTimeStr);</span><br><span class="line">            <span class="comment">// 当前的时间戳</span></span><br><span class="line">            Long currentTimeLong = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// (2)如果oldTimeLong小于当前时间了，说明之前持有锁的线程执行时间大于5秒了，就强制忽略该线程所持有的锁，重新设置自己的锁</span></span><br><span class="line">            <span class="keyword">if</span> (oldTimeLong &lt; currentTimeLong) &#123; </span><br><span class="line">                <span class="comment">// (3)调用getset方法获取之前的时间戳,注意这里会出现多个线程竞争，但肯定只会有一个线程会拿到第一次获取到锁时设置的expireTime</span></span><br><span class="line">                String oldTimeStr2 = shardedXCommands.getSet(lockKey, String.valueOf(System.currentTimeMillis() + <span class="number">5000</span>)); </span><br><span class="line">                <span class="comment">// (4)如果刚获取的时间戳和之前获取的时间戳一样的话,说明没有其他线程在占用这个锁,则此线程可以获取这个锁.</span></span><br><span class="line">                <span class="keyword">if</span> (oldTimeStr2 != <span class="literal">null</span> &amp;&amp; oldTimeStr.<span class="keyword">equals</span>(oldTimeStr2)) &#123; </span><br><span class="line">                    <span class="keyword">lock</span> = <span class="literal">true</span>; <span class="comment">// 获取锁标记</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 暂停50ms,重新循环</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lock</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://tech.imdada.cn/2017/06/30/daojia-redis/" target="_blank" rel="noopener">Redis在京东到家的订单中的使用</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码阅读利器-UML类图</title>
      <link href="/2019/04/27/uml/"/>
      <url>/2019/04/27/uml/</url>
      
        <content type="html"><![CDATA[<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="为什么要有类图？"><a href="#为什么要有类图？" class="headerlink" title="为什么要有类图？"></a>为什么要有类图？</h3><p>类图(Class diagram)主要用于描述系统的结构化设计。类图也是最常用的UML图，用类图可以显示出类、接口以及它们之间的静态结构和关系。</p><h3 id="领域UML类图-VS-实现UML类图"><a href="#领域UML类图-VS-实现UML类图" class="headerlink" title="领域UML类图 VS 实现UML类图"></a>领域UML类图 VS 实现UML类图</h3><p>通常在软件需求分析的时候，产品设计师需画一份领域UML类图，<br>设计阶段，研发会画一份实现UML类图，二者还是有区别的。</p><h2 id="读懂UML"><a href="#读懂UML" class="headerlink" title="读懂UML"></a>读懂UML</h2><ol><li>类继承</li></ol><p><img src="/images/uml_generalization.jpg" alt="我的头像"></p><ol start="3"><li>接口实现</li></ol><p><img src="/images/uml_realize.jpg" alt="我的头像"></p><ol start="4"><li>聚合关系</li></ol><p><img src="/images/uml_aggregation.jpg" alt="我的头像"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildGooseAggregate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">List</span>&lt;WildGoose&gt; wideGooses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>组合关系</li></ol><p><img src="/images/uml_composition.jpg" alt="我的头像"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> Wing wing;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        wing = <span class="keyword">new</span> Wing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>关联关系</li></ol><p><img src="/images/uml_association.jpg" alt="我的头像"></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Climate climate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>体现2个类的关系，一般以成员变量体现。</p><ol start="7"><li>依赖关系</li></ol><p><img src="/images/uml_dependency.jpg" alt="我的头像"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Programmer</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(Computer computer)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指类与类之间的联接，依赖关系表示一个类依赖于另一个类的定义。一般而言，依赖关系在Java语言中体现为局域变量、方法的形参，或者对静态方法的调用。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何平滑数据迁移不影响服务的可用性</title>
      <link href="/2019/04/26/%E9%9D%A2%E8%AF%95/"/>
      <url>/2019/04/26/%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>今天去壹钱包面试，问了一些解决方案，被有道题目难住了。</p><p>业务场景</p><blockquote><p>有个用户基础信息表，注册的时候，用户的手机号当前是明文保存在db，用户信息泄露的问题影响是不能容忍的，安全部要求把这个明文手机号改成密文，但是我们号称是24*7小时全天服务的公司，为保证系统可用性，请出个方案，平滑的将明文数据改成密文数据。</p></blockquote><p>初看这道题，觉得很简单。这里涉及到新老数据共存的问题。<br>我当时提出的方案是这样的：</p><blockquote><p>老用户数据加个是否加密的标示。新用户直接执行加密，存db。老用户查询的时候用明文，查询完，将明文转成秘文，更新到db并且标志位更新成秘文。<br>再加个补偿任务，降漏掉的明文改成秘文。</p></blockquote><p>无疑，太粗暴了。当系统发布的过程中，原逻辑代码的实例与加密的新实例，如果收到并发的2个同样手机的请求来，会导致重复手机号注册的问题。当时没有思绪，面试官让我回家想。。。</p><p>后来回到家，经过跟瑞强讨论，拿到了如下的解决方案。</p><p>时间换空间</p><pre><code>分四步1：加另一张表，跟原来表结构一样，用于存密文。2：然后代码增加一个同步数据的功能，将明文转成密文同步到新表去。然后新代码发布的过程中，老代码的服务可能存在的情况就是没有把数据同步到新表去，新代码的数据 老表跟新表都有。3：然后等待系统发布稳定后，再写个脚本将旧表数据 加密同步到新表去。4：切换业务代码到新表，删除旧表</code></pre><p>   我回复了面试的答案，面试官说，也是一种思路。他用一句话总结：“两个表双写是一个思路，本质上就是新老不能混在一起，为达到这个目的手段可以有多个” </p><hr><p>2019/4/28   </p><p>这二天，看了下架构方便的博客，看到了58沈剑的文章有提到这块关于<a href="http://www.10tiao.com/html/249/201703/2651959992/1.html" target="_blank" rel="noopener">“100亿数据平滑数据迁移,不影响服务”</a>的介绍,才明白，上面提到的解决方案，名叫“双写法”，这个方案是不完善的，体现在：<br><strong>数据迁移后，先写个校对数据校验工具保证新旧表的数据一致性，再切新表。</strong></p><blockquote><p>在一个极端的情况下，在数据迁移过程中，当提取旧表的某一条记录A，准备迁移到新表，这时候旧表进行了delete A的操作，这时候双写的时候，新表还没有A的记录，这就导致了新表多了一条数据，所以数据校对一致性工具还是必要的。</p></blockquote><p>另外学到了另外一套新的迁移方法，个人觉得比较麻烦。追日志法，可以看下这篇文章的介绍。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 数据迁移 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL事务默认隔离级别为什么是可重复读</title>
      <link href="/2019/04/25/mysql%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
      <url>/2019/04/25/mysql%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="ACID是做什么的"><a href="#ACID是做什么的" class="headerlink" title="ACID是做什么的"></a>ACID是做什么的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">简而言之，解释为</span><br><span class="line"></span><br><span class="line">    原子性（atomicity）</span><br><span class="line">    一致性（consistency）</span><br><span class="line">    隔离性（isolation）</span><br><span class="line">    持久性（durability）</span><br></pre></td></tr></table></figure><p><strong>为保证数据库事务操作的正确性与可靠性</strong>，必须满足以上4个特性。</p><hr><h3 id="事务隔离级别跟ACID有啥关系"><a href="#事务隔离级别跟ACID有啥关系" class="headerlink" title="事务隔离级别跟ACID有啥关系"></a>事务隔离级别跟ACID有啥关系</h3><p>上面ACID的4个特性中，其他三个都是针对单一事务，当出现并行事务的时候，就会存在以下几个问题：</p><ul><li>脏读</li><li>不可重复读</li><li>幻读</li></ul><p>数据库是怎么解决这个问题的呢？<br>简而言之，加锁。数据库提供了自动锁的功能，只需要用户指定会话的事务隔离级别，数据库就会分析SQL然后给事务访问的资源加入合适的锁。</p><p>事务隔离级别有以下</p><ul><li>读未提交(Read UnCommitted)</li><li>读已提交(Read Commited，后面简称RC)</li><li>可重复读(Repeatable Read，后面简称RR)</li><li>序列化读(Serializable)</li></ul><hr><h3 id="binlog的几种格式"><a href="#binlog的几种格式" class="headerlink" title="binlog的几种格式"></a>binlog的几种格式</h3><ul><li>statement:记录的是修改SQL语句</li><li>row：记录的是每行实际数据的变更 ，RC隔离级别下使用的binlog格式   </li><li>mixed：statement和row模式的混合</li></ul><hr><h2 id="MySQL事务默认隔离级别RR"><a href="#MySQL事务默认隔离级别RR" class="headerlink" title="MySQL事务默认隔离级别RR"></a>MySQL事务默认隔离级别RR</h2><p>我们知道，Oracal默认隔离级别是RC， Mysql默认隔离级别是RR，可不可以换成其他的？<br>数据库主从同步的方式是怎么样， 是通过binlog。<br>Mysql 5.0版本之前，binlog只支持STATEMENT这种格式。而这种格式<strong>在RC隔离级别下主从同步是有bug的。因此Mysql将RR作为默认的隔离级别！</strong></p><hr><h2 id="互联网项目中mysql应该选什么事务隔离级别？"><a href="#互联网项目中mysql应该选什么事务隔离级别？" class="headerlink" title="互联网项目中mysql应该选什么事务隔离级别？"></a>互联网项目中mysql应该选什么事务隔离级别？</h2><p>由上面我们知道了，mysql默认是可重复读的原因，那么我们可以升级Mysql到5,1即可以解决，<strong>互联网项目大部分用的是RC</strong>，为什么？</p><ul><li>可重复读存在GAP锁，死锁的概率相对读已提交大</li><li>在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> 隔离级别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL优化神器explain</title>
      <link href="/2019/04/20/SQL%E4%BC%98%E5%8C%96%E7%A5%9E%E5%99%A8explain/"/>
      <url>/2019/04/20/SQL%E4%BC%98%E5%8C%96%E7%A5%9E%E5%99%A8explain/</url>
      
        <content type="html"><![CDATA[<p>SQL优化，离不开explain。这里记下explain的常用列，方便以后查询。</p><p>这里提2个关键关于查询效率的列</p><hr><h3 id="type列"><a href="#type列" class="headerlink" title="type列"></a>type列</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">|  ALL              |  全表扫描</span><br><span class="line">|  index            |  索引全扫描</span><br><span class="line">|  range            |  索引范围扫描，常用语&lt;,&lt;=,&gt;=,between等操作</span><br><span class="line">|  ref                |  使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中</span><br><span class="line">|  eq_ref           |  类似ref，区别在于使用的是唯一索引，使用主键的关联查询</span><br><span class="line">|  <span class="keyword">const</span>/system  |  匹配单条记录，系统会把匹配行中的其他列作为常数处理，如主键或唯一索引查询</span><br><span class="line">|  <span class="literal">null</span>                |  MySQL不访问任何表或索引，直接返回结果</span><br></pre></td></tr></table></figure><p>sql效率从上到下逐渐增高</p><hr><h3 id="Extra列"><a href="#Extra列" class="headerlink" title="Extra列"></a>Extra列</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">| Using index | 表示使用索引</span><br><span class="line"></span><br><span class="line">如果只有 Using index，说明他没有查询到数据表，只用索引表就完成了这个查询，这个叫覆盖索引。如果同时出现Using where，代表使用索引来查找读取记录，也是可以用到索引的，但是需要查询到数据表。</span><br><span class="line"></span><br><span class="line">| Using where | 表示条件查询</span><br><span class="line"></span><br><span class="line">不读取表的所有数据，或不是仅仅通过索引就可以获取所有需要的数据，则会出现 Using where。</span><br><span class="line"></span><br><span class="line">| Using filesort |  排序语句ORDER BY的时候，会出现该信息。  </span><br><span class="line"></span><br><span class="line">| Using temporary | 使用了临时表，多表联合查询，结果排序的场合。</span><br></pre></td></tr></table></figure><p>sql效率从上到下逐渐增高</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile 必备知识</title>
      <link href="/2019/04/18/volatile%E4%B8%8Esynchronized%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/04/18/volatile%E4%B8%8Esynchronized%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>JMM虚拟机线程内存模型<br>:   每个线程，都是在自己的工作内存里面操作，想与另外一个线程共享变量值，需要将工作内存的变量刷到主内存，其他线程从主内存复制一份到工作线程来取值。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span></span><br><span class="line">保证了线程之间的可见性和有序性,但不具备原子性。被<span class="keyword">volatile</span>修饰的变量，线程每次取值都会</span><br><span class="line">从主内存复制到工作内存。</span><br></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized </span></span><br><span class="line">解释成<span class="keyword">JVM指令码 </span>就是monitorenter 和 monitorexit控制线程同步</span><br><span class="line">保证了线程的可见性、有序性和原子性。<span class="keyword">synchronized的锁来自</span></span><br><span class="line"><span class="keyword">对象头的锁，即MarkWord存放的锁标志。</span></span><br></pre></td></tr></table></figure><p>这里容易混淆的是 synchronized有序性，不代表能防止指令重排序，有序性的含义是代表保证线程执行的有序性，也只有volatile才有指令内存屏障，<br>所以双重检锁的单例模式，用了volatile修饰instance，防止new instance()的非原子性操作的指令重排序，导致拿到null的单例。</p><hr><p>2019-5-11</p><p>今天20:00饿了么蜂鸟配送的面试官电面了我，问了这块知识，原来这里可以有这么多东西可以问。</p><h2 id="volatile怎么保证线程的可见性，一个线程的变量变更，另一个线程是怎么感知的？"><a href="#volatile怎么保证线程的可见性，一个线程的变量变更，另一个线程是怎么感知的？" class="headerlink" title="volatile怎么保证线程的可见性，一个线程的变量变更，另一个线程是怎么感知的？"></a>volatile怎么保证线程的可见性，一个线程的变量变更，另一个线程是怎么感知的？</h2><p>JVM内存模型对volatile修饰的变量，定义了几个特殊规则：</p><ol><li>线程在工作内存中，使用该变量的时候，需要从主内存刷新到工作内存去。</li><li>线程修改了工作内存的变量值，需要刷新到主内存去，供其他线程使用。</li></ol><h2 id="为什么JVM将内存分为工作内存与主内存，即为什么有栈和堆"><a href="#为什么JVM将内存分为工作内存与主内存，即为什么有栈和堆" class="headerlink" title="为什么JVM将内存分为工作内存与主内存，即为什么有栈和堆"></a>为什么JVM将内存分为工作内存与主内存，即为什么有栈和堆</h2><p>主内存是线程共享的，不具有线程安全性，而工作内存是线程独有的，具有隔离性，线程安全<br>工作内存即CPU的高速缓存，为了执行效率高。</p><h2 id="volatile有哪些场景的应用"><a href="#volatile有哪些场景的应用" class="headerlink" title="volatile有哪些场景的应用"></a>volatile有哪些场景的应用</h2><ol><li>用于一些开关标识的场景（我只知道这个）</li><li>用于缓存的更新的场景，比如缓存失效的时候，多个线程并发获取该缓存，只允许一个线程去DB，拉取数据后塞进缓存后，供其他线程可见使用。</li><li>单例模式中，声明单例为volatile。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
            <tag> synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收器的选择</title>
      <link href="/2019/04/06/gc/"/>
      <url>/2019/04/06/gc/</url>
      
        <content type="html"><![CDATA[<p>其实，要不是读周志明的《深入理解java虚拟机》，垃圾回收器这个东西，我工作中是不需要接触到的。既然学习了，我就得沉淀点东西，以供后续复习。那么有这本书详细的描述了这块的知识，还需要我写点什么呢？恩，据我了解，周围同事读过这本书感受，都不是很流畅，读完有点懵，也记不住读过的内容，我要做的就是对知识的解剖的有条理性。肉是肉，骨头是骨头，码的整整齐齐。</p><hr><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>吞吐量<br>:   CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p><p>并行（Parallel）<br>:   指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p><p>并发（Concurrent）<br>:   指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</p><hr><h2 id="垃圾回收器分类"><a href="#垃圾回收器分类" class="headerlink" title="垃圾回收器分类"></a>垃圾回收器分类</h2><h3 id="按照回收线程数分："><a href="#按照回收线程数分：" class="headerlink" title="按照回收线程数分："></a>按照回收线程数分：</h3><p>1、串行垃圾回收器</p><blockquote><p>serial 收集器，serial old 收集器</p></blockquote><p>2、并行垃圾回收器</p><blockquote><p>parNew收集器，Parallel Scavenge，parallel old</p></blockquote><hr><h3 id="按照工作模式划分"><a href="#按照工作模式划分" class="headerlink" title="按照工作模式划分"></a>按照工作模式划分</h3><p>1、独占式垃圾回收器</p><blockquote><p>serial 收集器，serial old 收集器，parNew收集器，Parallel Scavenge，parallel old</p></blockquote><p>2、并发式垃圾回收器</p><blockquote><p>cms</p></blockquote><hr><h3 id="按照工作的内存区间划分："><a href="#按照工作的内存区间划分：" class="headerlink" title="按照工作的内存区间划分："></a>按照工作的内存区间划分：</h3><p>1、新生代</p><blockquote><p>serial， parNew， Parallel Scavenge</p></blockquote><p>2、老生代</p><blockquote><p>serial old， parallel old， cms</p></blockquote><hr><h3 id="按照碎片处理方式划分"><a href="#按照碎片处理方式划分" class="headerlink" title="按照碎片处理方式划分"></a>按照碎片处理方式划分</h3><p>压缩式垃圾回收器</p><blockquote><p>CMS收集器</p></blockquote><pre><code>CMS收集器提供了-XX:+UseCMSCompactAtFullCollection开启碎整理-XX:CMSFullGCsBeforeCompaction，设置执行多少次不压缩的FullGC后，跟着来一次带压缩的</code></pre><p>非压缩式垃圾回收器</p><blockquote><p>serial 收集器，serial old 收集器，parNew收集器，Parallel Scavenge，parallel old</p></blockquote><hr><h3 id="按照回收算法"><a href="#按照回收算法" class="headerlink" title="按照回收算法"></a>按照回收算法</h3><p>1、标记 清除 </p><blockquote><p>cms</p></blockquote><p>2、复制</p><blockquote><p>serial ，parNew， parallel scavenger</p></blockquote><p>3、标记 整理</p><blockquote><p>serial old， parallel old</p></blockquote><hr><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>Parallel Scavenge收集器无法与CMS收集器配合工作<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最佳搭配：</span><br><span class="line">ParNew + CMS（GC停顿时间短），</span><br><span class="line"><span class="keyword">Parallel</span> Scavenge+<span class="keyword">Parallel</span> <span class="keyword">Old</span>（吞吐量高）</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的加载机制与对象的实例化</title>
      <link href="/2019/03/26/jvm-class/"/>
      <url>/2019/03/26/jvm-class/</url>
      
        <content type="html"><![CDATA[<p>今天读到周志明的《深入理解java虚拟机》中类加载机制与对象的实例化这块，这本书说实话，还是有点生涩难懂，不过老祖先有祖训：“书读百遍，其义自见”，这句话是对的，我也是时隔2年，重新拜读的。</p><hr><h2 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h2><h3 id="成员变量与静态变量的区别"><a href="#成员变量与静态变量的区别" class="headerlink" title="成员变量与静态变量的区别"></a>成员变量与静态变量的区别</h3><p>静态变量 别名 类变量；成员变量 别名 实例变量<br>类的静态方法和静态变量属于类，作为类型数据保存在方法区，其生命周期取决于类，而实例方法和字段位于Java堆，其生命周期取决于对象的生命周期。</p><hr><h3 id="类初始化与类实例化的区别"><a href="#类初始化与类实例化的区别" class="headerlink" title="类初始化与类实例化的区别"></a>类初始化与类实例化的区别</h3><p>类的初始化是指虚拟机加载CLASS文件到内存中，将Class文件解析成JVM理解的执行指令，将类变量指定初始值，和类的函数方法等存入方法区，将class文件的符号引用转成方法区的直接引用。<br>类初始化之后就可以访问类的静态字段和方法，而访问类的非静态(实例)字段和方法，就需要创建类的对象实例，故<strong>类的实例化是在类的初始化之后，是在堆上创建一个该类的对象</strong></p><hr><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><ul><li>装载（加载class解释成虚拟机的方法区的运行期数据结构）</li><li>验证（解析class文件合法性）</li><li>准备(类变量设初始值，而非实例变量)</li><li>解析（符号引用转成直接引用）</li><li>初始化（类变量与static语句初始化）</li><li>使用、卸载</li></ul><h2 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h2><ul><li>虚拟机接受new指令，</li><li>类加载过程，父类静态变量与静态方法块执行完毕，子类静态变量与静态方法执行完毕</li><li>再执行父类的实例变量与构造方法，最后执行子类的实例化变量与构造方法</li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><pre><code class="javascript">public abstract <span class="class"><span class="keyword">class</span> <span class="title">ObjectCreateAEx</span> </span>{    ObjectCreateAEx(){        int a = getAV();        System.out.println(a);    }    public abstract int getAV();}public <span class="class"><span class="keyword">class</span> <span class="title">ObjectCreateBEx</span> <span class="keyword">extends</span> <span class="title">ObjectCreateAEx</span></span>{    private int a = <span class="number">10</span>;    private <span class="keyword">static</span> int b = <span class="number">11</span>;    private <span class="keyword">static</span> final  int c = <span class="number">12</span>;    ObjectCreateBEx(int a){        a = a;    }    @Override    public int  getAV() {       <span class="keyword">return</span> a;    }    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) {        ObjectCreateBEx  aEx =  <span class="keyword">new</span> ObjectCreateBEx(<span class="number">100</span>);    }}</code></pre><p>计算打印的结果是：0。为什么?因为类初始化的是静态变量b，而a是在实例化后才赋值成10的,<br>类实例化的过程是，先构造函数，再实例变量赋值。所以父类构造函数调用子类的变量，取得是子类还未赋值的初始化变量</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://github.com/huangchunwu/own" target="_blank" rel="noopener">示例代码</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类的加载机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM进程占用内存过高排查</title>
      <link href="/2019/03/22/jvmerror/"/>
      <url>/2019/03/22/jvmerror/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="32位的系统-进程内存限制最多2G？"><a href="#32位的系统-进程内存限制最多2G？" class="headerlink" title="32位的系统 进程内存限制最多2G？"></a>32位的系统 进程内存限制最多2G？</h3><p>32 位寻址空间只有 4GB 大小，于是 32 位应用程序进程最大只能用到 4GB 的内存。然而，除了应用程序本身要用内存，操作系统内核也需要使用。应用程序使用的内存空间分为用户空间和内核空间，每个 32 位程序的用户空间可独享前 2GB 空间（指针值为正数），而内核空间为所有进程共享 2GB 空间（指针值为负数）。所以，32 位应用程序实际能够访问的内存地址空间最多只有 2GB。</p><h3 id="JVM进程崩溃？"><a href="#JVM进程崩溃？" class="headerlink" title="JVM进程崩溃？"></a>JVM进程崩溃？</h3><p>1, 当超出JVM的分配的内存时，JAVA进程并不会退出只是结束当前的线程<br>2, 当服务器内存不够时，linux杀死使用内存的一个进程<br>3,  把系统拆分成多个服务部署在同一台机时需要特别注意，JVM启动时分配的内存只是申请（其实体现在VIRT），当一台服务器运行多个JAVA进程时请保留足够的可用内存 (大于分配给各个JVM的进程之和)</p><h3 id="TOP命令参数"><a href="#TOP命令参数" class="headerlink" title="TOP命令参数"></a>TOP命令参数</h3><p>VIRT 虚拟内存中含有共享库、共享内存、栈、堆，所有已申请的总内存空间。<br>RES  是进程正在使用的内存空间(栈、堆)，申请内存后该内存段已被重新赋值。<br>SHR  是共享内存正在使用的空间。<br>SWAP 交换的是已经申请，但没有使用的空间，包括(栈、堆、共享内存)。<br>DATA 是进程栈、堆申请的总空间。</p><h3 id="linux内存和JAVA堆中的关系"><a href="#linux内存和JAVA堆中的关系" class="headerlink" title="linux内存和JAVA堆中的关系"></a>linux内存和JAVA堆中的关系</h3><p>JAVA进程内存 = JVM进程内存+heap内存+ 永久代内存+ 本地方法栈内存+线程栈内存 +堆外内存 +socket 缓冲区内存</p><p>RES = JAVA正在存活的内存对象大小 + 未回收的对象大小  + 其它</p><p>VIART= JAVA中申请的内存大小，即 -Xmx  -Xms + 其它</p><p>其它 = 永久代内存+ 本地方法栈内存+线程栈内存 +堆外内存 +socket 缓冲区内存 +JVM进程内存</p><hr><h2 id="怎么排查"><a href="#怎么排查" class="headerlink" title="怎么排查"></a>怎么排查</h2><p>a: 实时查看：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">找到最耗内存的对象：</span><br><span class="line"><span class="selector-tag">jmap</span> <span class="selector-tag">-histo</span> 7311（带上<span class="selector-pseudo">:live</span>则表示先进行一次<span class="selector-tag">FGC</span>再统计，如<span class="selector-tag">jmap</span> <span class="selector-tag">-histo</span><span class="selector-pseudo">:live</span> 7311）</span><br></pre></td></tr></table></figure></p><p>b: 把heap文件dump下来分析：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=<span class="selector-tag">b</span>,file=heap<span class="selector-class">.bin</span> <span class="number">7311</span> （使用Eclipse mat分析）</span><br></pre></td></tr></table></figure></p><p>统计进程打开的句柄数：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> <span class="string">/proc/7311/fd</span> |wc -l</span><br></pre></td></tr></table></figure></p><p>统计进程打开的线程数：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> <span class="string">/proc/7311/task</span> |wc -l</span><br></pre></td></tr></table></figure></p><p>当前jvm线程数统计：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack <span class="number">7311</span> |grep ‘tid’|wc –l  (linux <span class="number">64</span>位系统中jvm线程默认栈大小为<span class="number">1</span>MB)</span><br></pre></td></tr></table></figure></p><p>查询堆内存分布情况：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap <span class="number">7311</span></span><br></pre></td></tr></table></figure></p><p>查看进程内存<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pmap <span class="number">7311</span></span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一列，内存块起始地址 </span><br><span class="line">第二列，占用内存大小 </span><br><span class="line">第三列，内存权限 </span><br><span class="line">第四列，内存名称，anon表示动态分配的内存，<span class="built_in">stack</span>表示栈内存 </span><br><span class="line">最后一行，占用内存总大小，请注意，此处为虚拟内存大小，占用的物理内存大小可以通过top查看</span><br></pre></td></tr></table></figure><p>jstat命令查看jvm的GC情况</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Options</span>，选项，我们一般使用 -gcutil 查看gc情况 </span><br><span class="line">vmid，VM的进程号，即当前运行的java进程号 </span><br><span class="line">interval，间隔时间，单位为秒或者毫秒 </span><br><span class="line"><span class="keyword">count</span>，打印次数，如果缺省则打印无数次</span><br></pre></td></tr></table></figure><blockquote><p> jstat -gc 7311 5000</p></blockquote><h2 id="JVM调优实战参考"><a href="#JVM调优实战参考" class="headerlink" title="JVM调优实战参考"></a>JVM调优实战参考</h2><hr><p><a href="https://www.analysys.cn/article/detail/20019016" target="_blank" rel="noopener">jvm疯狂吞占内存，罪魁祸首是谁？</a><br><a href="https://jeffinbao.github.io/2016/04/24/20160424-research-on-java-memory-overweighted/" target="_blank" rel="noopener">记一次Java内存占用过大排查</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>钉钉H5微应用开发总结</title>
      <link href="/2019/03/17/dingdingdev/"/>
      <url>/2019/03/17/dingdingdev/</url>
      
        <content type="html"><![CDATA[<p>今年，我又做了一个钉钉微应用的项目，第一次接触钉钉，把踩过的坑，记录下来，为后人乘凉所用。</p><hr><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>开放平台注册申请权限</li><li>选择钉钉应用类型，创建应用，获取AppKey，AppSecret，CORP_ID，</li><li>准备开发环境 静态页面、JS，CSS放在ngnix，本地接口用tomcat。</li><li>内网穿透，用于开发时候调试钉钉应用</li></ul><blockquote><p>减少代码耦合度，我采用前后端分离，没有采用freemaker等模板引擎工具，我将页面与接口放在不同服务器上，那么就有跨域问题，解决方案是ngnix，配置反向代理同个host不同端口，则可以解决JS跨域问题。</p></blockquote><blockquote><p> 钉钉下，有E应用（不成熟），微应用（较成熟）。我用的是相对成熟的微应用。另外应用还分，第三方企业内部应用，企业内部应用，第三方个人应用，移动应用接入。由于我的业务方需求，我选择的企业内部应用，注意看对应的文档，钉钉功能太混杂容易混淆。</p></blockquote><h2 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h2><h3 id="引入JS"><a href="#引入JS" class="headerlink" title="引入JS"></a>引入JS</h3><p>common.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"//g.alicdn.com/dingding/dingtalk-jsapi/2.0.57/dingtalk.open.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><h3 id="JSAPI免登授权码"><a href="#JSAPI免登授权码" class="headerlink" title="JSAPI免登授权码"></a>JSAPI免登授权码</h3><p>获取当前钉钉登录用户的账号信息，需要通过免登授权码换取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取免登授权码</span></span><br><span class="line">  dd.ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      dd.runtime.permission.requestAuthCode(&#123;</span><br><span class="line">          corpId: _config.corpId,</span><br><span class="line">          onSuccess: <span class="function"><span class="keyword">function</span>(<span class="params">info</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">var</span> _params = &#123;<span class="string">"code"</span>:info.code&#125;;</span><br><span class="line">              tools.getReqData(<span class="string">'/api/dd/getCurrentLoginUser'</span>, _params, getUserCall);<span class="comment">//通过免登授权码获取用户详细信息</span></span><br><span class="line">          &#125;,</span><br><span class="line">          onFail : <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">              alert(<span class="string">'fail: '</span> + <span class="built_in">JSON</span>.stringify(err));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      dd.error(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">          alert(<span class="string">'dd error: '</span> + <span class="built_in">JSON</span>.stringify(err));</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="JSAPI鉴权"><a href="#JSAPI鉴权" class="headerlink" title="JSAPI鉴权"></a>JSAPI鉴权</h3><p>需要用到钉钉的日历控件，组织机构多选弹出框等控件，所以需要鉴权<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//鉴权验证</span></span><br><span class="line">   dd.config(&#123;</span><br><span class="line">       agentId : _config.agentid,</span><br><span class="line">       corpId : _config.corpId,</span><br><span class="line">       timeStamp : _config.timeStamp,</span><br><span class="line">       nonceStr : _config.nonceStr,</span><br><span class="line">       signature : _config.signature,</span><br><span class="line">       jsApiList : [ <span class="string">'runtime.info'</span>, <span class="string">'biz.contact.choose'</span>,</span><br><span class="line">           <span class="string">'device.notification.confirm'</span>, <span class="string">'device.notification.alert'</span>,</span><br><span class="line">           <span class="string">'device.notification.prompt'</span>, <span class="string">'biz.ding.post'</span>,<span class="string">'biz.contact.complexPicker'</span>,</span><br><span class="line">           <span class="string">'biz.util.openLink'</span>,<span class="string">'biz.util.datepicker'</span> ]</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure></p><h3 id="获取TOKEN"><a href="#获取TOKEN" class="headerlink" title="获取TOKEN"></a>获取TOKEN</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在此方法中，为了避免频繁获取access_token，</span></span><br><span class="line"><span class="comment"> * 在距离上一次获取access_token时间在两个小时之内的情况，</span></span><br><span class="line"><span class="comment"> * 将直接从持久化存储中读取access_token</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 因为access_token和jsapi_ticket的过期时间都是7200秒</span></span><br><span class="line"><span class="comment"> * 所以在获取access_token的同时也去获取了jsapi_ticket</span></span><br><span class="line"><span class="comment"> * 注：jsapi_ticket是在前端页面JSAPI做权限验证配置的时候需要使用的</span></span><br><span class="line"><span class="comment"> * 具体信息请查看开发者文档--权限验证配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">static</span> <span class="built_in">String</span> getAccessToken() throws OApiException &#123;</span><br><span class="line">    long curTime = System.currentTimeMillis();</span><br><span class="line">    JSONObject accessTokenValue = (JSONObject) FileUtils.getValue(<span class="string">"accesstoken"</span>, Env.APP_KEY);</span><br><span class="line">    <span class="built_in">String</span> accToken = <span class="string">""</span>;</span><br><span class="line">    JSONObject jsontemp = <span class="keyword">new</span> JSONObject();</span><br><span class="line">    <span class="keyword">if</span> (accessTokenValue == <span class="literal">null</span> || curTime - accessTokenValue.getLong(<span class="string">"begin_time"</span>) &gt;= cacheTime) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServiceFactory serviceFactory = ServiceFactory.getInstance();</span><br><span class="line">            CorpConnectionService corpConnectionService = serviceFactory.getOpenService(CorpConnectionService.class);</span><br><span class="line">            accToken = corpConnectionService.getCorpToken(Env.APP_KEY, Env.APP_SECRET);</span><br><span class="line">            <span class="comment">// save accessToken</span></span><br><span class="line">            JSONObject jsonAccess = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            jsontemp.clear();</span><br><span class="line">            jsontemp.put(<span class="string">"access_token"</span>, accToken);</span><br><span class="line">            jsontemp.put(<span class="string">"begin_time"</span>, curTime);</span><br><span class="line">            jsonAccess.put(Env.APP_KEY, jsontemp);</span><br><span class="line">            <span class="comment">//真实项目中最好保存到数据库中</span></span><br><span class="line">            FileUtils.write2File(jsonAccess, <span class="string">"accesstoken"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accessTokenValue.getString(<span class="string">"access_token"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> accToken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取当前用户信息"><a href="#获取当前用户信息" class="headerlink" title="获取当前用户信息"></a>获取当前用户信息</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据免登授权码查询免登用户userId</span></span><br><span class="line"><span class="comment"> * @param accessToken</span></span><br><span class="line"><span class="comment"> * @param code</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> * @throws Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">static</span> CorpUserBaseInfo getUserInfo(<span class="built_in">String</span> accessToken, <span class="built_in">String</span> code) throws Exception &#123;</span><br><span class="line">    CorpUserService corpUserService = ServiceFactory.getInstance().getOpenService(CorpUserService.class);</span><br><span class="line">    <span class="keyword">return</span> corpUserService.getUserinfo(accessToken, code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="钉钉日历控件"><a href="#钉钉日历控件" class="headerlink" title="钉钉日历控件"></a>钉钉日历控件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   $(<span class="string">"#proBidOpent"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> curDate = (<span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear()) + <span class="string">'-'</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>().getMonth()) + <span class="string">'-'</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>().getDay);</span><br><span class="line">    dd.biz.util.datepicker(&#123;</span><br><span class="line">        format: <span class="string">'yyyy-MM-dd'</span>,<span class="comment">//注意：format只支持android系统规范，即2015-03-31格式为yyyy-MM-dd</span></span><br><span class="line">        value: curDate, <span class="comment">//默认显示日期</span></span><br><span class="line">        onSuccess : <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">            $(t).val(result.value);</span><br><span class="line">            <span class="comment">//onSuccess将在点击完成之后回调</span></span><br><span class="line">            <span class="comment">/*&#123;</span></span><br><span class="line"><span class="comment">             value: "2015-02-10"</span></span><br><span class="line"><span class="comment">             &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;,</span><br><span class="line">        onFail : <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            alert(<span class="built_in">JSON</span>.stringify(err));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="钉钉滑动选择人员控件"><a href="#钉钉滑动选择人员控件" class="headerlink" title="钉钉滑动选择人员控件"></a>钉钉滑动选择人员控件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  $(<span class="string">'#recorderName'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tx = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    dd.biz.contact.complexPicker(&#123;</span><br><span class="line">        title:<span class="string">"备案人员"</span>,            <span class="comment">//标题</span></span><br><span class="line">        corpId:_config.corpId,              <span class="comment">//企业的corpId</span></span><br><span class="line">        multiple:<span class="literal">true</span>,            <span class="comment">//是否多选</span></span><br><span class="line">        limitTips:<span class="string">"超出了"</span>,          <span class="comment">//超过限定人数返回提示</span></span><br><span class="line">        maxUsers:<span class="number">100</span>,            <span class="comment">//最大可选人数</span></span><br><span class="line">        pickedUsers:[],            <span class="comment">//已选用户</span></span><br><span class="line">        pickedDepartments:[],          <span class="comment">//已选部门</span></span><br><span class="line">        disabledUsers:[],            <span class="comment">//不可选用户</span></span><br><span class="line">        disabledDepartments:[],        <span class="comment">//不可选部门</span></span><br><span class="line">        requiredUsers:[],            <span class="comment">//必选用户（不可取消选中状态）</span></span><br><span class="line">        requiredDepartments:[],        <span class="comment">//必选部门（不可取消选中状态）</span></span><br><span class="line">        appId:_config.agentid,              <span class="comment">//微应用的Id</span></span><br><span class="line">        permissionType:<span class="string">"xxx"</span>,          <span class="comment">//可添加权限校验，选人权限，目前只有GLOBAL这个参数</span></span><br><span class="line">        responseUserOnly:<span class="literal">true</span>,        <span class="comment">//返回人，或者返回人和部门</span></span><br><span class="line">        startWithDepartmentId:<span class="number">0</span> ,   <span class="comment">//仅支持0和-1</span></span><br><span class="line">        onSuccess: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(result.selectedCount&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">var</span> empIds = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">var</span> empNames = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt; result.selectedCount;i++)&#123;</span><br><span class="line">                    empIds = empIds + result.users[i].emplId+<span class="string">","</span>;</span><br><span class="line">                    empNames = empNames + result.users[i].name+<span class="string">","</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                empIds = empIds.substring(<span class="number">0</span>,empIds.length<span class="number">-1</span>);</span><br><span class="line">                empNames = empNames.substring(<span class="number">0</span>,empNames.length<span class="number">-1</span>);</span><br><span class="line">                $(tx).val(empNames);</span><br><span class="line">                <span class="keyword">var</span> attr_hidden = $(tx).attr(<span class="string">"attr_hidden"</span>);</span><br><span class="line">                $(<span class="string">"#"</span>+attr_hidden).val(empIds);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;,</span><br><span class="line">        onFail : <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            alert(<span class="built_in">JSON</span>.stringify(err));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://github.com/huangchunwu/myDingding" target="_blank" rel="noopener">开源代码</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 钉钉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近的所思、所感</title>
      <link href="/2019/03/16/myThink/"/>
      <url>/2019/03/16/myThink/</url>
      
        <content type="html"><![CDATA[<p>最近比较烦。 </p><ul><li style="list-style: none"><input type="checkbox" checked> 借了一屁股债，买了一套房，还在交易中。</li><li style="list-style: none"><input type="checkbox" checked> 丈母娘眼睛需要做个小手术，预约了住院时间</li><li style="list-style: none"><input type="checkbox"> 小孩3岁，该是上幼儿园的年纪了，可是没有居住证。</li></ul><hr><ul><li>第一个感触就是，结婚了，你要处理的是二个家庭的问题。</li><li>第二个感触就是，靠技术，不能度过中年危机.</li><li>有个房贷，你开始害怕失业了</li><li>在大公司，认识到自己就是一个螺丝钉，很难挤到中层去</li></ul><p>关于本末倒置</p><p>热播剧《都挺好》中有这样一个桥段，小姑凉高二开始做推荐课程，遇到一位老板，<br>老板问他一节课多少钱，总共多长时间学完，<br>小姑凉迷惑的如实回答了，<br>老板说，你知道我花这么长时间上课，耽误我挣多少钱了吗？<br>然后老板问小姑凉，你年纪这么小，挣钱做什么？<br>小姑凉说挣钱去国外留学。<br>老板问，去国外留学做什么？<br>菇凉说，挣大钱，出人头地。<br>老板问，那留学要花多少钱，你得攒多久才能凑满。<br>小姑凉算了算，要10年。<br>老板说，那10年后，就是你攒够钱了，去留学回来，还是个打工赚钱，还是一穷二白。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【在线工具】JSON字符串转为javaBean对象</title>
      <link href="/2019/03/13/jsonutil/"/>
      <url>/2019/03/13/jsonutil/</url>
      
        <content type="html"><![CDATA[<p>一款免费的在线的JSON字符串转为javaBean对象工具，提高工作效率，记录一下</p><p><a href="https://www.bejson.com/json2javapojo/new/" target="_blank" rel="noopener">JSON字符串转为javaBean对象在线工具</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC工具类之exchanger</title>
      <link href="/2019/03/09/exchanger/"/>
      <url>/2019/03/09/exchanger/</url>
      
        <content type="html"><![CDATA[<p>日常开发使用，JUC工具类里面的exchanger使用场景不多，既然看到了就学了一下记一下。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>exchanger 用于二个线程，规定一个交换点，当双方线程到达这个点后，相互交换数据的效果。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>用于2个线程交互数据使用；经典生产消费者</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java concurrent 包</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 用于2个线程交互数据使用</span></span><br><span class="line"><span class="comment"> * 规定一个交换点，当双方线程到达这个点后，相互交换数据</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Created by huangchunwu on 2019/3/4.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;Integer&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Runnable r1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.print(Thread.currentThread().getName() + <span class="string">"get "</span> + exchanger.exchange(<span class="number">2019</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Runnable r2 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.print(Thread.currentThread().getName() + <span class="string">"get "</span> + exchanger.exchange(<span class="number">2018</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r1);</span><br><span class="line">        t1.setName(<span class="string">"A"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r2);</span><br><span class="line">        t2.setName(<span class="string">"B"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://github.com/huangchunwu/own" target="_blank" rel="noopener">示例代码</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal如何防止内存泄漏</title>
      <link href="/2019/02/02/threadlocal/"/>
      <url>/2019/02/02/threadlocal/</url>
      
        <content type="html"><![CDATA[<p> 工作五年了，对ThreadLocal原理还不是很清楚，o(<em>￣︶￣</em>)o。今天来分析下，使用threadLocal时候，导致内存泄漏的原理。</p><hr><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>1、用于存放线程局部变量。<br>2、一个线程都会维护一个threadLocalMap,threadLocal包装成弱引用作为key，用户的值作为value,装在entry数组里面。</p></blockquote><hr><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><blockquote><p>set(T value) 存储线程局部变量值<br>get() 获取线程局部变量值<br>remove() 移除线程局部变量，即entry数组</p></blockquote><hr><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>1、ThreadLocal层面<br> 通常，线程结束了，threadLocal作为弱引用的key，此时key==null,Entry也就被GC了<br>2、ThreadLocalMap层面<br> 如果线程存活比较久，线程局部变量作为value的数量如果超过容量的2/3(没有扩大容量时是10个)，则会触发Entry的回收</p><hr><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>内存泄露<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、如果使用线程池，要注意手动清理threadLocal</span><br><span class="line"><span class="number">2</span>、如果线程消亡了，threadLocal==null,此时entry还是被强引用的话，</span><br><span class="line">   threadLocalMap不会被回收，造成内存泄露</span><br></pre></td></tr></table></figure></p><hr><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1</span>、可以用于单个线程的参数的存储，模板方法的上下文</span><br><span class="line"><span class="number">2</span>、Java7中的SimpleDateFormat不是线程安全的，可以用ThreadLocal来解决这个问题</span><br><span class="line"><span class="number">3</span>、InheritableThreadLocal可以跨线程共享ThreadLocal变量，用于将主线程的变量传递给子线程中例如用户标识（user <span class="built_in">id</span>）或事务标识（<span class="keyword">transaction</span> <span class="built_in">id</span>），但不能是有状态对象，例如 JDBC Connection</span><br></pre></td></tr></table></figure><p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：<br>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value<br>永远无法回收，造成内存泄露。</p><p>所以JDK建议将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。</p><hr><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://github.com/huangchunwu/own" target="_blank" rel="noopener">示例代码</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Threadlocal </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思维导图在线工具</title>
      <link href="/2019/02/02/swtools/"/>
      <url>/2019/02/02/swtools/</url>
      
        <content type="html"><![CDATA[<p>今天发现一款免费的在线的思维导图工具，蛮不错的，记录一下</p><p><a href="https://www.processon.com" target="_blank" rel="noopener">思维导图在线工具</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并行计算框架forkJoin框架</title>
      <link href="/2019/01/25/forkjoin/"/>
      <url>/2019/01/25/forkjoin/</url>
      
        <content type="html"><![CDATA[<h2 id="框架思想"><a href="#框架思想" class="headerlink" title="框架思想"></a>框架思想</h2><p>当业务系统遇到要处理大任务的时候，可以拆分成小任务来执行，最后将小任务的执行结果汇总，返回给大任务，简称为“分而治之”，jdk7提供了forkJoin框架，Hadoop提供了MapReduce。</p><hr><h2 id="适合场景"><a href="#适合场景" class="headerlink" title="适合场景"></a>适合场景</h2><blockquote><p>多核CPU服务器<br>CPU密集的应用，<br>并行计算的应用</p></blockquote><hr><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><h3 id="forkJoinTask-抽象类"><a href="#forkJoinTask-抽象类" class="headerlink" title="forkJoinTask 抽象类"></a>forkJoinTask 抽象类</h3><p>不直接使用，直接使用以下子类提供的fork与join方法</p><blockquote><p>RecursiveAction 无返回值<br>RecursiveTask 有返回值</p></blockquote><hr><h3 id="forkJoinPool-线程池"><a href="#forkJoinPool-线程池" class="headerlink" title="forkJoinPool 线程池"></a>forkJoinPool 线程池</h3><p>提供了forkJoin线程池。每一个工作线程维护一份双端队列，队列里面存放待执行的任务，线程池内部使用“工作窃取算法”，即工作线程自己的队列任务处理完了，可以“窃取”其他线程的队列的任务去执行，提供的CPU利用率，所以工作线程不要用于IO流操作等超时任务。</p><hr><h3 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h3><p>每一个工作线程维护一份双端队列，当工作线程处理完自己的队列后，会窃取其他线程的队列帮忙处理，充分使用所有线程资源，直到处理完所有的队列，这才是特别的地方。</p><hr><h3 id="fork-Join框架基本模板"><a href="#fork-Join框架基本模板" class="headerlink" title="fork/Join框架基本模板"></a>fork/Join框架基本模板</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">(任务足够小)</span></span>&#123;</span><br><span class="line">    进行计算；</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    将任务分为两个部分；</span><br><span class="line">    结合两个子任务结果；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 临界值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    private <span class="keyword">static</span> final int THRESHOLD = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    int start=<span class="number">0</span>;</span><br><span class="line">    int end=<span class="number">100000</span>;</span><br><span class="line">    int sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    public CountTask(int start,int end)&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Integer compute() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (end-start&lt;THRESHOLD)&#123;</span><br><span class="line">            <span class="keyword">for</span> (int i=start;i&lt;end;i++)&#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            int middle = (start + end)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            RecursiveTask&lt;Integer&gt; left_task =  <span class="keyword">new</span> CountTask(start,middle);</span><br><span class="line">            RecursiveTask&lt;Integer&gt; right_task =  <span class="keyword">new</span> CountTask(middle,end);</span><br><span class="line"></span><br><span class="line">            invokeAll(left_task,right_task);</span><br><span class="line"></span><br><span class="line">            sum = left_task.join() + right_task.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分而治之</span></span><br><span class="line"><span class="comment"> * forkjoin 线程池是双端队列，采用窃取算法</span></span><br><span class="line"><span class="comment"> * Created by huangchunwu on 2019/1/21.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTaskTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public  <span class="keyword">void</span> testInvokeForkPool()&#123;</span><br><span class="line">        <span class="comment">// 创建一个通用池，这个是jdk1.8提供的功能</span></span><br><span class="line">        ForkJoinPool pool = ForkJoinPool.commonPool();</span><br><span class="line"></span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        ForkJoinTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>,<span class="number">999999999</span>);</span><br><span class="line">        Integer result = (Integer) pool.invoke(task);</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"Fork/join sum: "</span> + result + <span class="string">" in "</span> + (endTime - startTime) + <span class="string">" ms."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public  <span class="keyword">void</span> testsubmitForkPool()&#123;</span><br><span class="line">        <span class="comment">// 创建一个通用池，这个是jdk1.8提供的功能</span></span><br><span class="line">        ForkJoinPool pool = ForkJoinPool.commonPool();</span><br><span class="line"></span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        ForkJoinTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>,<span class="number">999999999</span>);</span><br><span class="line">        pool.submit(task);</span><br><span class="line">        Integer result =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = (Integer) task.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"Fork/join sum: "</span> + result + <span class="string">" in "</span> + (endTime - startTime) + <span class="string">" ms."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/jinggod/p/8490511.html" target="_blank" rel="noopener">Fork-Join分治编程介绍（一）</a><br><a href="https://github.com/huangchunwu/own" target="_blank" rel="noopener">示例源码</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> forkJoin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Guava Cache 学习记录</title>
      <link href="/2019/01/15/guava-cache/"/>
      <url>/2019/01/15/guava-cache/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么使用Guava-Cache？"><a href="#为什么使用Guava-Cache？" class="headerlink" title="为什么使用Guava Cache？"></a>为什么使用Guava Cache？</h2><p>guava cache属于JVM内存的缓存,其实JAVA本地缓存框架有ecache，简单点有HashMap作为缓存容器,那么，为什么推荐用guava cache呢,比如以下：<br>1、设置缓存的过期时间,遵循LRU原则移除过期KEY<br>2、缓存的定期刷新<br>3、如何防止缓存穿透</p><p>LRU原则是指 Least Recently Used  最近最少使用,即活性不高的缓存会被淘汰掉</p><p>如果自己实现起来难度较大，谷歌开发对缓存操作作了封装，方便研发的重心集中在业务处理，无需关心底层实现，无需重复造轮子。</p><p>我们常用的是redis可以实现分布式缓存，为什么推荐用guava cache呢<br>1、同时造成了业务系统 强依赖于网络和redis服务器的稳定性<br>2、网络请求的效率远远没有本地内存快。</p><hr><h2 id="哪些场景适合使用Guava-cache"><a href="#哪些场景适合使用Guava-cache" class="headerlink" title="哪些场景适合使用Guava cache"></a>哪些场景适合使用Guava cache</h2><p>通常缓存的用法，先请求本地缓存，如果本地缓存未命中，则去请求DB。<br>Guava cache 是本地缓存，所以适合数据量小的数据量的情况下使用。</p><hr><h2 id="Guava-cache特性"><a href="#Guava-cache特性" class="headerlink" title="Guava cache特性"></a>Guava cache特性</h2><p>1、缓存不会自动刷新，需满足2个条件，<code>过期了</code>，<code>有get请求</code><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ListeningExecutorService executorService =</span><br><span class="line">           MoreExecutors.listeningDecorator(Executors.newSingleThreadExecutor());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// remove listener</span></span><br><span class="line">   <span class="keyword">static</span> RemovalListener&lt;<span class="keyword">String</span>, Integer&gt; removalListener = <span class="keyword">new</span> RemovalListener&lt;<span class="keyword">String</span>, Integer&gt;() &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> onRemoval(RemovalNotification&lt;<span class="keyword">String</span>, Integer&gt; removal) &#123;</span><br><span class="line">           System.out.<span class="built_in">println</span>(DateUtils.time() +<span class="string">"cause:"</span> + removal.getCause() + <span class="string">" key:"</span> + removal.getKey() + <span class="string">" value:"</span></span><br><span class="line">                   + removal.getValue());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">static</span> LoadingCache&lt;<span class="keyword">String</span>, Integer&gt; loadingCache = CacheBuilder.newBuilder()</span><br><span class="line">           .maximumSize(<span class="number">10</span>)  <span class="comment">//最多存放十个数据</span></span><br><span class="line">        <span class="comment">// .expireAfterWrite(3, TimeUnit.SECONDS)  //缓存200秒</span></span><br><span class="line">           .refreshAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">           .removalListener(removalListener)</span><br><span class="line">           .recordStats()   <span class="comment">//开启 记录状态数据功能</span></span><br><span class="line">           .build(<span class="keyword">new</span> CacheLoader&lt;<span class="keyword">String</span>, Integer&gt;() &#123;</span><br><span class="line">               <span class="comment">//数据加载，默认返回-1,也可以是查询操作，如从DB查询</span></span><br><span class="line">               @Override</span><br><span class="line">               <span class="keyword">public</span> Integer load(<span class="keyword">String</span> <span class="built_in">key</span>) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                   System.out.<span class="built_in">println</span>(DateUtils.time() + <span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;load&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>);</span><br><span class="line">                   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//有些键不需要刷新，并且我们希望刷新是异步完成的</span></span><br><span class="line">               @Override</span><br><span class="line">               <span class="keyword">public</span> ListenableFuture&lt;Integer&gt; reload(<span class="keyword">final</span> <span class="keyword">String</span> <span class="built_in">key</span>, <span class="keyword">final</span> Integer oldValue) &#123;</span><br><span class="line">                   System.out.<span class="built_in">println</span>(DateUtils.time() + <span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;reload&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>);</span><br><span class="line">                   <span class="comment">// we need to load new values asynchronously, so that calls to read values from the cache don't block</span></span><br><span class="line">                   ListenableFuture&lt;Integer&gt; listenableFuture = executorService.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">                       @Override</span><br><span class="line">                       <span class="keyword">public</span> Integer call() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               Integer value = load(<span class="built_in">key</span>);</span><br><span class="line">                               <span class="keyword">return</span> value;</span><br><span class="line">                           &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                               <span class="keyword">return</span> oldValue;</span><br><span class="line">                           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br><span class="line">                   <span class="keyword">return</span> listenableFuture;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure></p><p>执行结果<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Sun</span> <span class="selector-tag">Jan</span> 20 18<span class="selector-pseudo">:55</span><span class="selector-pseudo">:46</span> <span class="selector-tag">CST</span> 2019&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<span class="selector-tag">put</span>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"><span class="selector-tag">Sun</span> <span class="selector-tag">Jan</span> 20 18<span class="selector-pseudo">:55</span><span class="selector-pseudo">:50</span> <span class="selector-tag">CST</span> 2019&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<span class="selector-tag">get</span>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"><span class="selector-tag">Sun</span> <span class="selector-tag">Jan</span> 20 18<span class="selector-pseudo">:55</span><span class="selector-pseudo">:50</span> <span class="selector-tag">CST</span> 2019&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<span class="selector-tag">reload</span>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"><span class="selector-tag">Sun</span> <span class="selector-tag">Jan</span> 20 18<span class="selector-pseudo">:55</span><span class="selector-pseudo">:50</span> <span class="selector-tag">CST</span> 2019&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<span class="selector-tag">load</span>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"><span class="selector-tag">Sun</span> <span class="selector-tag">Jan</span> 20 19<span class="selector-pseudo">:11</span><span class="selector-pseudo">:37</span> <span class="selector-tag">CST</span> 2019&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<span class="selector-tag">cause</span><span class="selector-pseudo">:REPLACED</span> <span class="selector-tag">key</span><span class="selector-pseudo">:1</span> <span class="selector-tag">value</span><span class="selector-pseudo">:1</span></span><br></pre></td></tr></table></figure></p><p>由上述程序执行结果，可以看出，cache的key进行put后4S没有reload，第5S的时候get请求后，reload才开始。</p><p>2、Guava Cache的load方法不能返回null，否则抛异常，Guava Cache的get方法先在本地缓存中取，如果不存在，则会触发load方法。但load方法不能返回null。 </p><hr><h2 id="Guava-cache-有什么替代品"><a href="#Guava-cache-有什么替代品" class="headerlink" title="Guava cache 有什么替代品"></a>Guava cache 有什么替代品</h2><p>Caffeine 宣称拥有比 Guava Cache 高几倍的读写效率</p><hr><h2 id="Guava-cache使用步骤"><a href="#Guava-cache使用步骤" class="headerlink" title="Guava cache使用步骤"></a>Guava cache使用步骤</h2><h3 id="引入maven的POM"><a href="#引入maven的POM" class="headerlink" title="引入maven的POM"></a>引入maven的POM</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Guava-Cache初始化"><a href="#Guava-Cache初始化" class="headerlink" title="Guava Cache初始化"></a>Guava Cache初始化</h3><h4 id="Cache-Callable"><a href="#Cache-Callable" class="headerlink" title="Cache Callable"></a>Cache Callable</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final static <span class="keyword">Cache</span>&lt;<span class="built_in">Integer</span>, <span class="keyword">String</span>&gt; <span class="keyword">cache</span> = CacheBuilder.newBuilder()</span><br><span class="line">           //设置<span class="keyword">cache</span>的初始大小为<span class="number">10</span>，要合理设置该值</span><br><span class="line">           .initialCapacity(<span class="number">10</span>)</span><br><span class="line">           //设置并发数为<span class="number">5</span>，即同一时间最多只能有<span class="number">5</span>个线程往<span class="keyword">cache</span>执行写入操作</span><br><span class="line">           .concurrencyLevel(<span class="number">5</span>)</span><br><span class="line">           //设置<span class="keyword">cache</span>中的数据在写入之后的存活时间为<span class="number">10</span>秒</span><br><span class="line">           .expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">           //构建<span class="keyword">cache</span>实例</span><br><span class="line">           .build();</span><br></pre></td></tr></table></figure><h4 id="LoadingCache"><a href="#LoadingCache" class="headerlink" title="LoadingCache"></a>LoadingCache</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final <span class="keyword">static</span> LoadingCache&lt;<span class="keyword">String</span>, Integer&gt; cache = CacheBuilder.<span class="keyword">new</span><span class="type">Builder</span>()</span><br><span class="line">           .maximumSize(<span class="number">10</span>)  <span class="comment">//最多存放十个数据</span></span><br><span class="line">           .expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)  <span class="comment">//缓存200秒</span></span><br><span class="line">           .recordStats()   <span class="comment">//开启 记录状态数据功能</span></span><br><span class="line">           .build(<span class="keyword">new</span> <span class="type">CacheLoader</span>&lt;<span class="keyword">String</span>, Integer&gt;() &#123;</span><br><span class="line">               <span class="comment">//数据加载，默认返回-1,也可以是查询操作，如从DB查询</span></span><br><span class="line">               @Override</span><br><span class="line">               <span class="keyword">public</span> Integer load(<span class="keyword">String</span> key) throws Exception &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure><h3 id="Guava-Cache常用方法"><a href="#Guava-Cache常用方法" class="headerlink" title="Guava Cache常用方法"></a>Guava Cache常用方法</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 该接口的实现被认为是线程安全的，即可在多线程中调用 </span></span><br><span class="line"><span class="comment"> * 通过被定义单例使用 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> interface Cache&lt;K, V&gt; &#123;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 通过key获取缓存中的value，若不存在直接返回null </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  V getIfPresent(<span class="keyword">Object</span> <span class="built_in">key</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 通过key获取缓存中的value，若不存在就通过valueLoader来加载该value </span></span><br><span class="line"><span class="comment">   * 整个过程为 "if cached, return; otherwise create, cache and return" </span></span><br><span class="line"><span class="comment">   * 注意valueLoader要么返回非null值，要么抛出异常，绝对不能返回null </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  V <span class="built_in">get</span>(K <span class="built_in">key</span>, Callable&lt;? extends V&gt; valueLoader) <span class="keyword">throws</span> ExecutionException;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 添加缓存，若key存在，就覆盖旧值 </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  <span class="keyword">void</span> put(K <span class="built_in">key</span>, V value);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 删除该key关联的缓存 </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  <span class="keyword">void</span> invalidate(<span class="keyword">Object</span> <span class="built_in">key</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 删除所有缓存 </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  <span class="keyword">void</span> invalidateAll();  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 执行一些维护操作，包括清理缓存 </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  <span class="keyword">void</span> cleanUp();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存回收"><a href="#缓存回收" class="headerlink" title="缓存回收"></a>缓存回收</h2><p><code>基于容量回收</code> </p><p>CacheBuilder.maximumSize(long)</p><p><code>定时回收</code>   </p><p>expireAfterAccess(long, TimeUnit) -&gt; KEY在一定时间内没有读写，则失效，下次读取直接load（）中取</p><p>expireAfterWrite(long, TimeUnit) -&gt; 避免了缓存穿透的问题，保证了数据的实时性，牺牲的是性能，当数据expire的时候，大量get请求过来的时候，只有一个请求会去load（）数据，而没有更新完成之前，其他全部请求会被block（每个线程都要轮询的判断lock状态）</p><p><code>基于引用回收</code> </p><pre><code>CacheBuilder.weakKeys()：使用弱引用存储键CacheBuilder.weakValues()：使用弱引用存储值CacheBuilder.softValues()：使用软引用存储值。</code></pre><hr><h2 id="缓存刷新"><a href="#缓存刷新" class="headerlink" title="缓存刷新"></a>缓存刷新</h2><p>refreshAfterWrite(long, TimeUnit) -&gt; 机制是并非超时时间到就自动刷新，而是请求 get的时候才会触发refresh，默认refresh是同步请求新值，可以重写refresh方法改成异步。如果有大量并发请求的时候，只会有一个请求get-&gt;reload同步执行，其他线程返回旧值.</p><ul><li><p>弊端<br>吞吐量低的应用，在超过过期时间时，大量并发get请求时，大部分拿到的是很久前的旧值，导致数据脏读。</p></li><li><p>如何解决？<br>可以同时使用expireAfterWrite设置key过期时间，比如每2s刷新一次新值，设置expireAfterWrite为5s为过期时间，则当key值5s没有访问的话，则第5s的时候强制取load新值，解决了脏读问题，也同时避免了缓存穿透问题。</p></li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>Guava是如何实现，当缓存过期，只有一个请求去DB捞取数据的？</p><p>在《JAVA并发编程的艺术》里面有提到过这个方案，使用concurrentHashMap与futureTask,<br>futureTask的特点就是 当一个线程需要等待某一个线程的计算结果的场景。</p><hr><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://github.com/ben-manes/caffeine" target="_blank" rel="noopener">Caffeine github</a><br><a href="https://github.com/huangchunwu/own" target="_blank" rel="noopener">示例代码</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> Guava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo主题优化</title>
      <link href="/2019/01/11/hexo-improve/"/>
      <url>/2019/01/11/hexo-improve/</url>
      
        <content type="html"><![CDATA[<p>hexo搭建好博客后，需要给博客的装扮下，记录一下一些主题优化技巧</p><h2 id="安装文章计数插件WordCount"><a href="#安装文章计数插件WordCount" class="headerlink" title="安装文章计数插件WordCount"></a>安装文章计数插件WordCount</h2><p>第一步：在blog根目录下，执行以下命令<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-wordcount <span class="comment">--save</span></span><br></pre></td></tr></table></figure></p><hr><p>第二步：修改配置文件<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启字数统计</span></span><br><span class="line"><span class="attr">word_count:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><hr><p>第三步：修改主题 swig 布局</p><p>找到<code>themes/next/layout/_macro/post.swig</code>文件，修改【字数统计】，找到如下代码：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">title</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; __('post.wordcount') &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; wordcount(post.content) &#125;&#125;</span><span class="xml">字</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>同理，我们修改【阅读时长】，修改后如下：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">title</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; __('post.min2read') &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; min2read(post.content) &#125;&#125;</span><span class="xml"> 分钟</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><h2 id="增加站内搜索"><a href="#增加站内搜索" class="headerlink" title="增加站内搜索"></a>增加站内搜索</h2><p>第一步：在blog根目录下，执行以下命令<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-<span class="keyword">search</span> <span class="comment">--save</span></span><br></pre></td></tr></table></figure></p><p>第二步：编辑站点配置文件，新增以下内容到任意位置：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">search:</span></span><br><span class="line"><span class="symbol">  path:</span> search.xml</span><br><span class="line"><span class="symbol">  field:</span> post</span><br><span class="line"><span class="symbol">  format:</span> html</span><br><span class="line"><span class="symbol">  limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure></p><p>第三步：接着修改主题配置文件_config.yml为<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBatch+MYSQL仓库+运维监控后台项目记录</title>
      <link href="/2019/01/11/springbatch/"/>
      <url>/2019/01/11/springbatch/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Spring Batch 是一款轻量级地适合企业级应用的批处理框架，值得注意的是，不同于其他调度框架，Spring Batch不提供调度功能。</p><hr><h3 id="批处理过程"><a href="#批处理过程" class="headerlink" title="批处理过程"></a>批处理过程</h3><p>批处理可以分为以下几个步骤：</p><ol><li>读取数据</li><li>按照业务处理数据</li><li>归档数据的过程</li></ol><hr><h3 id="Spring-Batch给我们提供了什么？"><a href="#Spring-Batch给我们提供了什么？" class="headerlink" title="Spring Batch给我们提供了什么？"></a>Spring Batch给我们提供了什么？</h3><ol><li>统一的读写接口 </li><li>丰富的任务处理方式</li><li>灵活的事务管理及并发处理 </li><li>日志、监控、任务重启与跳过等特性 </li></ol><hr><a id="more"></a><h3 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h3><table><thead><tr><th>名称</th><th style="text-align:right">用途</th></tr></thead><tbody><tr><td>JobRepository</td><td style="text-align:right">用于注册和存储Job的容器</td></tr><tr><td>JobLauncher</td><td style="text-align:right">用于启动Job</td></tr><tr><td>Job</td><td style="text-align:right">实际要执行的作业，包含一个或多个step</td></tr><tr><td>step</td><td style="text-align:right">步骤，批处理的步骤一般包含ItemReader, ItemProcessor, ItemWriter</td></tr><tr><td>ItemReader</td><td style="text-align:right">从给定的数据源读取item</td></tr><tr><td>ItemProcessor</td><td style="text-align:right">在item写入数据源之前进行数据整理</td></tr><tr><td>ItemWriter</td><td style="text-align:right">把Chunk中包含的item写入数据源。</td></tr><tr><td>Chunk</td><td style="text-align:right">数据块，给定数量的item集合，让item进行多次读和处理，当满足一定数量的时候再一次写入。</td></tr><tr><td>TaskLet</td><td style="text-align:right">子任务表， step的一个事务过程，包含重复执行，同步/异步规则等。</td></tr></tbody></table><hr><h3 id="job-step-tasklet-和-chunk-关系"><a href="#job-step-tasklet-和-chunk-关系" class="headerlink" title="job, step, tasklet 和 chunk 关系"></a>job, step, tasklet 和 chunk 关系</h3><p>一个job对应至少一个step，一个step对应0或者1个TaskLet，一个taskLet对应0或者1个Chunk<br><img src="http://static.bookstack.cn/projects/SpringBatchReferenceCN/01_introduction/fig3-chunks.png" alt="我的头像"></p><hr><h3 id="实战：批处理excel插入数据库"><a href="#实战：批处理excel插入数据库" class="headerlink" title="实战：批处理excel插入数据库"></a>实战：批处理excel插入数据库</h3><h4 id="定义数据仓库"><a href="#定义数据仓库" class="headerlink" title="定义数据仓库"></a>定义数据仓库</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 内存仓库  --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;bean id="jobRepository" class="org.springframework.batch.core.repository.support.MapJobRepositoryFactoryBean"/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 数据库仓库  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">batch:job-repository</span> <span class="attr">id</span>=<span class="string">"jobRepository"</span> <span class="attr">data-source</span>=<span class="string">"dataRepDruidDataSource"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">isolation-level-for-create</span>=<span class="string">"SERIALIZABLE"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">table-prefix</span>=<span class="string">"BATCH_"</span> <span class="attr">max-varchar-length</span>=<span class="string">"1000"</span> /&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="定义启动器"><a href="#定义启动器" class="headerlink" title="定义启动器"></a>定义启动器</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 作业调度器，用来启动job,引用作业仓库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jobLauncher"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.batch.core.launch.support.SimpleJobLauncher"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobRepository"</span> <span class="attr">ref</span>=<span class="string">"jobRepository"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="定义JOB"><a href="#定义JOB" class="headerlink" title="定义JOB"></a>定义JOB</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">batch:job</span> <span class="attr">id</span>=<span class="string">"userBatchJobName"</span> <span class="attr">restartable</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">batch:step</span> <span class="attr">id</span>=<span class="string">"userStep"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">batch:tasklet</span> <span class="attr">allow-start-if-complete</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                       <span class="attr">start-limit</span>=<span class="string">"1"</span> <span class="attr">task-executor</span>=<span class="string">"taskExecutor"</span> <span class="attr">throttle-limit</span>=<span class="string">"5"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">batch:chunk</span> <span class="attr">reader</span>=<span class="string">"userReader"</span> <span class="attr">writer</span>=<span class="string">"userWriter"</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">processor</span>=<span class="string">"userProcessor"</span> <span class="attr">commit-interval</span>=<span class="string">"5"</span> <span class="attr">retry-limit</span>=<span class="string">"10"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">batch:retryable-exception-classes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">batch:include</span> <span class="attr">class</span>=<span class="string">"org.springframework.dao.DuplicateKeyException"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">batch:include</span> <span class="attr">class</span>=<span class="string">"java.sql.BatchUpdateException"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">batch:include</span> <span class="attr">class</span>=<span class="string">"java.sql.SQLException"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">batch:retryable-exception-classes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">batch:chunk</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">batch:tasklet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">batch:step</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">batch:job</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"taskExecutor"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 线程池维护线程的最少数量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"corePoolSize"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 线程池维护线程所允许的空闲时间 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"keepAliveSeconds"</span> <span class="attr">value</span>=<span class="string">"30000"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 线程池维护线程的最大数量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"300"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 线程池所使用的缓冲队列 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"queueCapacity"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="定义ItemReader"><a href="#定义ItemReader" class="headerlink" title="定义ItemReader"></a>定义ItemReader</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;bean <span class="built_in">id</span>=<span class="string">"userReader"</span> <span class="built_in">class</span>=<span class="string">"org.springframework.batch.item.file.FlatFileItemReader"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"lineMapper"</span> <span class="keyword">ref</span>=<span class="string">"lineMapper"</span>/&gt;</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"resource"</span> value=<span class="string">"classpath:message/batch-data-source.csv"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将每行映射成对象 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lineMapper"</span> <span class="attr">class</span>=<span class="string">"org.springframework.batch.item.file.mapping.DefaultLineMapper"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lineTokenizer"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.batch.item.file.transform.DelimitedLineTokenizer"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"delimiter"</span> <span class="attr">value</span>=<span class="string">","</span>/&gt;</span><span class="comment">&lt;!-- 根据某种分隔符分割 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"names"</span> <span class="attr">value</span>=<span class="string">"id,name"</span> /&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fieldSetMapper"</span>&gt;</span><span class="comment">&lt;!-- 将拆分后的字段映射成对象 --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.hcw.core.batch.UserFieldSetMapper"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="定义ItemWriter"><a href="#定义ItemWriter" class="headerlink" title="定义ItemWriter"></a>定义ItemWriter</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;bean <span class="built_in">id</span>=<span class="string">"userWriter"</span> <span class="built_in">class</span>=<span class="string">"com.hcw.core.batch.MyBatchItemWriter"</span> scope=<span class="string">"step"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"statementId"</span> value=<span class="string">"com.hcw.core.batch.dao.UserToMapper.batchInsert"</span>/&gt;</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="keyword">ref</span>=<span class="string">"sqlSessionFactoryTo"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="定义ItemProcessor"><a href="#定义ItemProcessor" class="headerlink" title="定义ItemProcessor"></a>定义ItemProcessor</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"userProcessor"</span> <span class="attribute">class</span>=<span class="string">"com.hcw.core.batch.UserItemProcessor"</span>/&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="定义jobRepository的数据源"><a href="#定义jobRepository的数据源" class="headerlink" title="定义jobRepository的数据源"></a>定义jobRepository的数据源</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  &lt;bean <span class="built_in">id</span>=<span class="string">"dataRepDruidDataSource"</span> <span class="built_in">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span></span><br><span class="line">  init-method=<span class="string">"init"</span> destroy-method=<span class="string">"close"</span>&gt;</span><br><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"url"</span> value=<span class="string">"$&#123;jdbc.mysql.rep.connection.url&#125;"</span> /&gt;</span><br><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"username"</span> value=<span class="string">"$&#123;jdbc.mysql.rep.connection.username&#125;"</span> /&gt;</span><br><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"password"</span> value=<span class="string">"$&#123;jdbc.mysql.rep.connection.password&#125;"</span> /&gt;</span><br><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"filters"</span> value=<span class="string">"$&#123;jdbc.mysql.rep.connection.filters&#125;"</span> /&gt;</span><br><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"maxActive"</span> value=<span class="string">"$&#123;jdbc.mysql.rep.connection.maxActive&#125;"</span> /&gt;</span><br><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"initialSize"</span> value=<span class="string">"$&#123;jdbc.mysql.rep.connection.initialSize&#125;"</span> /&gt;</span><br><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"maxWait"</span> value=<span class="string">"$&#123;jdbc.mysql.rep.connection.maxWait&#125;"</span> /&gt;</span><br><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"minIdle"</span> value=<span class="string">"$&#123;jdbc.mysql.rep.connection.minIdle&#125;"</span> /&gt;</span><br><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"timeBetweenEvictionRunsMillis"</span></span><br><span class="line">  value=<span class="string">"$&#123;jdbc.mysql.rep.connection.timeBetweenEvictionRunsMillis&#125;"</span> /&gt;</span><br><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"minEvictableIdleTimeMillis"</span></span><br><span class="line">  value=<span class="string">"$&#123;jdbc.mysql.rep.connection.minEvictableIdleTimeMillis&#125;"</span> /&gt;</span><br><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"validationQuery"</span></span><br><span class="line">  value=<span class="string">"$&#123;jdbc.mysql.rep.connection.validationQuery&#125;"</span> /&gt;</span><br><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"testWhileIdle"</span></span><br><span class="line">  value=<span class="string">"$&#123;jdbc.mysql.rep.connection.testWhileIdle&#125;"</span> /&gt;</span><br><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"testOnBorrow"</span> value=<span class="string">"$&#123;jdbc.mysql.rep.connection.testOnBorrow&#125;"</span> /&gt;</span><br><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"testOnReturn"</span> value=<span class="string">"$&#123;jdbc.mysql.rep.connection.testOnReturn&#125;"</span> /&gt;</span><br><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"poolPreparedStatements"</span></span><br><span class="line">  value=<span class="string">"$&#123;jdbc.mysql.rep.connection.poolPreparedStatements&#125;"</span> /&gt;</span><br><span class="line">&lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"maxPoolPreparedStatementPerConnectionSize"</span></span><br><span class="line">  value=<span class="string">"$&#123;jdbc.mysql.rep.connection.maxPoolPreparedStatementPerConnectionSize&#125;"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h4 id="启动JOB"><a href="#启动JOB" class="headerlink" title="启动JOB"></a>启动JOB</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动tomcat,打开启动页面</span><br></pre></td></tr></table></figure><p> <img src="https://upload-images.jianshu.io/upload_images/3666580-7ef9722ce9bed1bf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我的头像"></p><hr><h3 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h3><p><a href="https://github.com/huangchunwu/batch-framework" target="_blank" rel="noopener">batch-framework</a></p><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.bookstack.cn/read/SpringBatchReferenceCN/README.md" target="_blank" rel="noopener">SpringBatch 中文文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 批处理 </tag>
            
            <tag> SpringBatch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018，这一年</title>
      <link href="/2019/01/01/summary/"/>
      <url>/2019/01/01/summary/</url>
      
        <content type="html"><![CDATA[<p>引用习大大的祝贺词中的一句”岁月不居，时节如流”，18年就这样过去了，总结一下这年的收获。</p><h3 id="关于读书，多读比不读好"><a href="#关于读书，多读比不读好" class="headerlink" title="关于读书，多读比不读好"></a>关于读书，多读比不读好</h3><p>这一年，很庆幸的是，我认识了很上进的同事，他对我的影响是让我开始认识到看书的重要性，开始学会在书里寻找价值与智慧。今年我看了32本书，我也不记得自己还记得几个句子，又或者对我带来多大的影响，知乎上也有人提到“<strong>经常看书的人和不看书的人有什么区别</strong>”，我当时是这样回答的：</p><blockquote><p>从我身边的例子来说，有位同事，大学不务正业，泡在金庸武侠世界里，连书中的某段武林秘籍口诀也能倒背如流,当然，他也涉及其它领域。跟他对话，他猛不丁get到一个念头，帮你把你的处境与书中某个人的遭遇相关联,并引出解决方案，这时候你就能领略到读书的用处了，书中记录的是过来人的生活经验，会帮助你解决目前的问题。</p></blockquote><p>就我的感受是自己读完一本本书后，内心很充实，生活中有些问题能从书中找到答案，思想变得更加豁达了，而没有像以前看问题那么局面，自然比以前少发牢骚了，生活也更积极了。</p><h3 id="关于工作：“凑合着”做，“凑合着”过，把自己也“凑合着”活了"><a href="#关于工作：“凑合着”做，“凑合着”过，把自己也“凑合着”活了" class="headerlink" title="关于工作：“凑合着”做，“凑合着”过，把自己也“凑合着”活了"></a>关于工作：“凑合着”做，“凑合着”过，把自己也“凑合着”活了</h3><p>刚工作那会，多加班一个小时，都觉得自己吃亏了，如果再对比下别人家的公司加班晚餐与加班费，心里戾气就更严重了，对待工作也消极，演变成了“凑合”。现在仔细想想，”凑合”在我生活中扮演的戏份真的很多，学业上凑合着，工作上凑合着，说到底是对自己凑合着。在公司的每一分一秒，都是自己参与，都属于自己“刻意练习”的机会，可以想成是公司提供的带薪培训的一个很好的平台。我觉得，思想转变了，态度自然就能转变，我就会往好的方向走。</p><h3 id="关于生活：有想法，撸起袖子，去做；而想得多而畏惧不做"><a href="#关于生活：有想法，撸起袖子，去做；而想得多而畏惧不做" class="headerlink" title="关于生活：有想法，撸起袖子，去做；而想得多而畏惧不做"></a>关于生活：有想法，撸起袖子，去做；而想得多而畏惧不做</h3><p>现如今，逃离北上广的人太多了，18年这一年，在上海，作为外地人，我需要为自己留在上海做一些努力。儿子二岁了，面临上幼儿园的问题，外地人上本地幼儿园需要居住证积分，我办了居住证、辗转2次办成了积分。为了以后出行的方便，我把驾照也考了，就不提我苦逼的考了一年的经过了。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结合项目，谈谈软件设计原则</title>
      <link href="/2018/12/20/softdesign/"/>
      <url>/2018/12/20/softdesign/</url>
      
        <content type="html"><![CDATA[<p>从事开发这么多年，陆陆续续开发了N个系统了。对软件设计原则，一直没有认真深入的探讨过，当熟读这些原则，结合项目，发现很多违背设计的地方，作为优秀的研发，应该早点跟三字经一样熟读这些原则才对啊。下面我结合最近的项目谈谈自己的见解。</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>官方解释 对扩展是开放的，对修改是关闭的。<br>简单地说，就是你要提供这样的函数方法或者类，你可以进行重载，复写，但是不需要修改。例如，刚开始，火车票电子票出票流程，我在controller层调用business层提供的出票方法。设计的时候，预测到后期还有其他票种，我抽象出一个IOccupyBusiness接口，里面就一个请求占位方法，实现该接口新建实现类EticketOccupyBusiness，在occupy（）写电子票的业务。<br>过了不久，产品提了一个配送票的出票需求，我只需要添加一个实现IOccupyBusiness的实现类DeliveryOccupyBusiness，在occupy（）写配送票的业务，我并没有修改已有类，和方法，复合了开闭原则。</p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>客户端不应该依赖它不需要的接口；<br>一个类对另一个类的依赖应该建立在最小的接口上。<br>简单说，不要给调用方暴露它不需要调用的方法。<br>还拿上述的例子，如果遵循单一职责原则，请求占位，与占位反馈，可以设计成同个接口的不同方法。如果需求是这样的，配送票的占位是虚占，不需要耗时的请求12306实占，所以可以占位接口设计成同步反馈结果，则没有异步反馈的方法。那么配送票的实现类就多暴露出一个占位反馈的方法，不符合接口隔离原则，于是我又将占位接口，粒度细化了，分占位请求接口，占位反馈接口。这样，占位的实现类就不会实现多余的接口了。</p><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>官方定义：有且仅有一个让类变化的原因。<br>通俗地说，就是一个类只负责一个职责，比如上面我们谈到的，占位的类，不能同时有出票的功能。<br>单一职责与接口隔离原则有点类似，单一职责偏向于职能，接口隔离偏向于接口粒度。</p><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>官方定义：所以引用基类的地方必须透明的使用子类对象<br>通俗地说，就是子类可以扩展父类的功能，但不能改变父类的功能，即不能重载、复写父类的方法</p><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>官方定义：一个对象应该对其他对象保持最少的了解</p><h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>官方定义 译文：<br>高层模块不应该依赖于低层模块，它们应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p><p>基于以上学习，我在项目里面实现了这样类图<br><img src="https://upload-images.jianshu.io/upload_images/3666580-199028910dc13372.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我的头像"></p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring声明式事务失效的分析过程</title>
      <link href="/2018/12/16/aop/"/>
      <url>/2018/12/16/aop/</url>
      
        <content type="html"><![CDATA[<h3 id="问题的背景"><a href="#问题的背景" class="headerlink" title="问题的背景"></a>问题的背景</h3><p>在途牛，庆幸的是遇到了几个很正面的人，我也是从阅读其中一位同事的博客才发现了spring声明式事务的这个坑，说实话，我平时开发很少用事务，因为不好控制粒度，事务也是高并发的绊脚石。</p><hr><h3 id="问题的现象"><a href="#问题的现象" class="headerlink" title="问题的现象"></a>问题的现象</h3><p>为了理解方便，下面我用伪代码说明问题详细<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Class exampleService&#123;</span><br><span class="line">    <span class="comment">//不加事务，本身不需要事务介入</span></span><br><span class="line">   public <span class="keyword">void</span> methodA（）&#123;</span><br><span class="line">      <span class="comment">//耗时操作</span></span><br><span class="line">      ······</span><br><span class="line">     <span class="comment">//调用B</span></span><br><span class="line">      methodB（）；</span><br><span class="line">      ······</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//声明了事务</span></span><br><span class="line">   @Transactional </span><br><span class="line">   public <span class="keyword">void</span> methodB（）&#123;</span><br><span class="line">      insert();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"操作db失败"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行完代码后，现象是发现methodB的插入的数据没有回滚，像我一样不知道的同学就纳闷了，下面来具体分析下为啥出现事务无效的现象。</p><hr><h3 id="问题的分析"><a href="#问题的分析" class="headerlink" title="问题的分析"></a>问题的分析</h3><p>这里来复习一下spring的声明式事务，无非就是spring的二大核心之一：AOP。</p><blockquote><p>AOP的实现原理是java的动态代理。</p></blockquote><blockquote><p>spring实现动态代理有二种方式，其中一个就是cglib，另一个是jdk代理。</p></blockquote><blockquote><p>cglib的原理是jvm调用native方法即ASM，操作class字节码另生成代理类。</p></blockquote><blockquote><p>AOP注解的方法，生成的代理类，并在方法执行前，加入事务的开启，执行后加入事务提交操作</p></blockquote><p>基于这些认知，我们看spring的声明式事务为什么失效。<br>exampleService有二个方法：methodA 是普通方法，methodB是另一个声明了事务方法，class编译出了一个AOP代理类exampleServiceProxy,<br>上述出现问题的调用关系是：</p><pre><code>exampleService.methodA（）调用的是内部方法exampleService.methodB().由此看出methodB并没有被Proxy类通知到。</code></pre><p>正确的调用关系是：</p><pre><code>exampleServiceProxy.methodA()--&gt;exampleServiceProxy.methodB().</code></pre><hr><h3 id="怎么避免此类问题"><a href="#怎么避免此类问题" class="headerlink" title="怎么避免此类问题"></a>怎么避免此类问题</h3><p>知道了原理，我们解决此类问题的方法，要么是新建一个类并将methodB移进来。<br>要么是用编程式事务。</p><hr><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><blockquote><p>说下最近发生的事情，不喜跳过。这段时间工作比较忙，每天有6个小时的有效工作时间，在和南京总部的度假团队，一起开发火车票改签项目，说下这个项目的感受，又是一堆的CURD，这也是敲业务代码的弊端。我想避免温水煮青蛙，突破一下自己，改变了以往的开发习惯，先把以前大冰哥的改签代码，用Visio将业务流程画了一遍，我也不清楚这样有什么好处，有个“上海交大”的同事告诉我这样用处大，只能自己体会，我想人家那么优秀的学历说的话总归有点道理的。等我画完整个流程图后，渐渐的有了点启发，一边心里骂着之前代码结构的设计，一边寻思着开始代码的重构,目前正在紧张的开发中。回过头来想画流程图的好处，我就觉得，看代码的速度放慢了，思考空间也更大了些，于是启发就更多了些。</p></blockquote><hr><p>5/8号<br>昨天面试的时候，被面试官问到这块知识，面试官问如果获取代理对象的目标对象？我不知道了，不过现在知道了。<br>像上面那类问题，另外一个解决方案就是，直接获取spring容器的代理对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Class exampleService&#123;</span><br><span class="line">    <span class="comment">//不加事务，本身不需要事务介入</span></span><br><span class="line">   public <span class="keyword">void</span> methodA（）&#123;</span><br><span class="line">      <span class="comment">//耗时操作</span></span><br><span class="line">      ······</span><br><span class="line">     <span class="comment">//调用B</span></span><br><span class="line">     ((BaseClass)SpringUtil.getBean(<span class="string">"exampleService"</span>)).methodB（）；</span><br><span class="line">      ······</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//声明了事务</span></span><br><span class="line">   @Transactional </span><br><span class="line">   public <span class="keyword">void</span> methodB（）&#123;</span><br><span class="line">      insert();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"操作db失败"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果获取代理对象的目标对象？我不好用语言表达清楚，先贴个别人写的解答吧<br><a href="https://jinnianshilongnian.iteye.com/blog/1613222" target="_blank" rel="noopener">在spring中获取代理对象代理的目标对象工具类</a></p><p>参考资料：<br><a href="http://www.cnblogs.com/nnngu/p/8627662.html" target="_blank" rel="noopener">Spring的编程式事务和声明式事务</a><br><a href="https://www.cnblogs.com/lcngu/p/5339555.html" target="_blank" rel="noopener">Spring aop的实现原理</a><br><a href="https://www.cnblogs.com/flyingeagle/articles/7102282.html" target="_blank" rel="noopener">Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐适合敲代码时候听的空灵音乐</title>
      <link href="/2018/12/16/music/"/>
      <url>/2018/12/16/music/</url>
      
        <content type="html"><![CDATA[<p>日常时间大多数都在敲代码中，当周围环境比较纷杂吵闹，又或者内心比较杂乱烦躁的时候，我都会放上一小段音乐来平复一下自己，通常我会听一些轻音乐，我喜欢青山流水的旋律，或者简简单单的下雨的声音，个人觉得很适合敲代码的时候听。</p><p>现在流行的歌手，参差不齐，商业化向导向的市场已经很难诞生出一个纯粹做音乐的人了，如果听音乐，我个人建议听像朴树、许巍这样的灵魂歌者，他们的音乐简简单单是自己某个阶段的内心表达。</p><p><strong>轻音乐，我建议听下久石让的，最近发现班得瑞的音乐也很好听，推荐下。</strong></p><p><a href="https://www.bandari.net/play" target="_blank" rel="noopener">点击听《班得瑞的轻音乐》</a></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发调试远程连接设备</title>
      <link href="/2018/12/02/adb/"/>
      <url>/2018/12/02/adb/</url>
      
        <content type="html"><![CDATA[<p>最近在做一个Android-PAD项目，之前本地调试，基本靠sdk模拟器，或者数据线连接手机，学会了新招，可以远程连接设备进行调试，即远程adb。</p><hr><p>前提条件：一台Android设备，并且ROOT</p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">su</span><br><span class="line">setprop service.adb.tcp.port <span class="number">9999</span>  <span class="comment">#设置端口，默认是5555</span></span><br><span class="line">stop adbd</span><br><span class="line">start adbd</span><br><span class="line">netstat<span class="comment">#看下adb端口是否打开</span></span><br></pre></td></tr></table></figure><p>最后在终端执行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator\AppData\Local\Android\Sdk\platform-tools&gt;adb connect <span class="number">192.168</span><span class="number">.2</span><span class="number">.104</span> <span class="number">9999</span>连接成功</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown编辑器</title>
      <link href="/2018/12/02/markdown/"/>
      <url>/2018/12/02/markdown/</url>
      
        <content type="html"><![CDATA[<p>hexo博客搭建好了，可以开始写文章了，所谓“工欲善其事必先利其器”，推荐在线<a href="https://www.zybuluo.com/mdeditor#1356808" target="_blank" rel="noopener">MarkDown编辑器</a>，可以立即预览文章样式。</p><hr><p>  ==2019/4/27== 发现有道云笔记的markdown工具，提供了一些自动化的标签工具，让写作更方便了</p>]]></content>
      
      
      <categories>
          
          <category> 搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+GitHub搭建个人博客</title>
      <link href="/2018/12/01/hello-world/"/>
      <url>/2018/12/01/hello-world/</url>
      
        <content type="html"><![CDATA[<hr><p>做IT的没有一个自己的博客，不像话，于是现学现卖搭建了这个博客，记录下来，种下大树，便于后人乘凉</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><blockquote><ul><li>电脑一台，本文以win7为例</li><li>给电脑安装git</li><li>安装node.js</li><li>申请GitHub </li></ul></blockquote><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>在我的电脑里面建一个文件夹blog<br>然后进入blog文件夹，右击选择“Git Bash”<br>输入命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pm install -g cnpm --registry=https://registry.npm.taobao.org<span class="comment">#安装npm</span></span><br><span class="line">cnpm install -g hexo-cli</span><br><span class="line">cnpm install hexo --save</span><br><span class="line">hexo -v <span class="comment">#安装完成后，在输入命令，验证是否安装正确</span></span><br></pre></td></tr></table></figure><h2 id="启动hexo"><a href="#启动hexo" class="headerlink" title="启动hexo"></a>启动hexo</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo init <span class="comment">#初始化hexo</span></span><br><span class="line"></span><br><span class="line">cnpm install <span class="comment">#安装生成器</span></span><br><span class="line"></span><br><span class="line">hexo s -g <span class="comment">#运行hexo,以后要在本地运行博客只要输入该命令即可</span></span><br></pre></td></tr></table></figure><p>打开浏览器，输入localhost:4000,就可以在本地看到你的个人博客了<br>停止运行<br>按住Ctrl+C键即可停止</p><h2 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h2><p>使用notepad++编辑器打开blog/_config.yml文件，进行配置<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#博客名称</span></span><br><span class="line">title: 我的博客</span><br><span class="line"><span class="comment">#副标题</span></span><br><span class="line">subtitle: 一天进步一点</span><br><span class="line"><span class="comment">#简介</span></span><br><span class="line">description: 记录生活点滴</span><br><span class="line"><span class="comment">#博客作者</span></span><br><span class="line">author: John Doe</span><br><span class="line"><span class="comment">#博客语言</span></span><br><span class="line">language: zh-CN</span><br><span class="line"><span class="comment">#时区</span></span><br><span class="line">timezone:</span><br><span class="line"><span class="comment">#博客地址,与申请的GitHub一致</span></span><br><span class="line">url: http://elfwalk.github.io</span><br><span class="line">root: /</span><br><span class="line"><span class="comment">#博客链接格式</span></span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line">new_post_name: :title.md <span class="comment"># File name of new posts</span></span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false <span class="comment"># Transform title into titlecase</span></span><br><span class="line">external_link: true <span class="comment"># Open external links in new tab</span></span><br><span class="line">filename_case: <span class="number">0</span></span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: true</span><br><span class="line">  tab_replace:</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"><span class="comment">#日期格式</span></span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"><span class="comment">#分页，每页文章数量</span></span><br><span class="line">per_page: <span class="number">10</span></span><br><span class="line">pagination_dir: page</span><br><span class="line"><span class="comment">#博客主题</span></span><br><span class="line">theme: landscape</span><br><span class="line"><span class="comment">#发布设置</span></span><br><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  <span class="comment">#elfwalk改为你的github用户名</span></span><br><span class="line">  repository: https://github.com/huangchunwu/huangchunwu.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><h2 id="编写文章"><a href="#编写文章" class="headerlink" title="编写文章"></a>编写文章</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"new article"</span></span><br></pre></td></tr></table></figure><p>之后在source/_posts目录下面，多了一个new-article.md的文件<br>打开之后我们会看到：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: new article</span><br><span class="line">date: <span class="number">2014</span><span class="number">-11</span><span class="number">-01</span> <span class="number">20</span>:<span class="number">10</span>:<span class="number">33</span></span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>文件的开头是属性，采用统一的yaml格式，用三条短横线分隔。下面是文章正文。<br>文章的正文支持markdown格式，建议你先学习一下它的语法。markdown不像html似的一大堆标签，很简单，只有几个符号。<br>新建、删除或修改文章后，不需要重启hexo server，刷新一下即可预览。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment"># 删除已经生成的静态页面</span></span><br><span class="line">hexo generate <span class="comment">#生成静态网页</span></span><br><span class="line">hexo deploy <span class="comment">#部署到GitHub</span></span><br><span class="line"></span><br><span class="line">hexo g -d <span class="comment">#也可简写为（一起执行上边两个命令）</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
