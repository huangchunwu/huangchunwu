<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SQL优化神器explain</title>
      <link href="/2019/04/20/SQL%E4%BC%98%E5%8C%96%E7%A5%9E%E5%99%A8explain/"/>
      <url>/2019/04/20/SQL%E4%BC%98%E5%8C%96%E7%A5%9E%E5%99%A8explain/</url>
      
        <content type="html"><![CDATA[<p>SQL优化，离不开explain。这里记下explain的常用列，方便以后查询。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">explain select * <span class="keyword">from</span> table where id = <span class="number">1</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">结果</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> javascript</span><br><span class="line"></span><br><span class="line">+----+-------------+-------+-------+------------------+---------+---------+-------+------+-------+</span><br><span class="line">| id | select_type | table | type  | possible_keys    | key     | key_len | ref   | rows | Extra |</span><br><span class="line">+----+-------------+-------+-------+------------------+---------+---------+-------+------+-------+</span><br><span class="line">| <span class="number">1</span>  | SIMPLE      | user  | <span class="keyword">const</span> | PRIMARY,id_unidx | PRIMARY | <span class="number">4</span>       | <span class="keyword">const</span> | <span class="number">1</span>    |       |</span><br><span class="line">+----+-------------+-------+-------+------------------+---------+---------+-------+------+-------+</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这里提2个关键关于查询效率的列</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">type列</span></span><br><span class="line"><span class="string">------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> javascript</span><br><span class="line"></span><br><span class="line">|  ALL              |  全表扫描</span><br><span class="line">|  index            |  索引全扫描</span><br><span class="line">|  range            |  索引范围扫描，常用语&lt;,&lt;=,&gt;=,between等操作</span><br><span class="line">|  ref                |  使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中</span><br><span class="line">|  eq_ref           |  类似ref，区别在于使用的是唯一索引，使用主键的关联查询</span><br><span class="line">|  <span class="keyword">const</span>/system  |  匹配单条记录，系统会把匹配行中的其他列作为常数处理，如主键或唯一索引查询</span><br><span class="line">|  <span class="literal">null</span>                |  MySQL不访问任何表或索引，直接返回结果</span><br></pre></td></tr></table></figure><p>sql效率从上到下逐渐增高</p><hr><h2 id="Extra列"><a href="#Extra列" class="headerlink" title="Extra列"></a>Extra列</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">| Using index | 表示使用索引</span><br><span class="line"></span><br><span class="line">如果只有 Using index，说明他没有查询到数据表，只用索引表就完成了这个查询，这个叫覆盖索引。如果同时出现Using where，代表使用索引来查找读取记录，也是可以用到索引的，但是需要查询到数据表。</span><br><span class="line"></span><br><span class="line">| Using where | 表示条件查询</span><br><span class="line"></span><br><span class="line">不读取表的所有数据，或不是仅仅通过索引就可以获取所有需要的数据，则会出现 Using where。</span><br><span class="line"></span><br><span class="line">| Using filesort |  排序语句ORDER BY的时候，会出现该信息。  </span><br><span class="line"></span><br><span class="line">| Using temporary | 使用了临时表，多表联合查询，结果排序的场合。</span><br></pre></td></tr></table></figure><p>sql效率从上到下逐渐增高</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile与synchronized的区别</title>
      <link href="/2019/04/18/volatile%E4%B8%8Esynchronized%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/04/18/volatile%E4%B8%8Esynchronized%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>JMM虚拟机线程内存模型<br>:   每个线程，都是在自己的工作内存里面操作，想与另外一个线程共享变量值，需要将工作内存的变量刷到主内存，其他线程从主内存复制一份到工作线程来取值。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">volatile</span><br><span class="line">保证了线程之间的可见性和有序性,但不具备原子性。被volatile修饰的变量，线程每次取值都会从主内存复制到工作内存。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized </span><br><span class="line">解释成JVM指令码 就是monitorenter 和 monitorexit控制线程同步</span><br><span class="line">保证了线程的可见性、有序性和原子性</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
            <tag> synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收器的选择</title>
      <link href="/2019/04/06/gc/"/>
      <url>/2019/04/06/gc/</url>
      
        <content type="html"><![CDATA[<p>其实，要不是读周志明的《深入理解java虚拟机》，垃圾回收器这个东西，我工作中是不需要接触到的。既然学习了，我就得沉淀点东西，以供后续复习。那么有这本书详细的描述了这块的知识，还需要我写点什么呢？恩，据我了解，周围同事读过这本书感受，都不是很流畅，读完有点懵，也记不住读过的内容，我要做的就是对知识的解剖的有条理性。肉是肉，骨头是骨头，码的整整齐齐。</p><hr><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>吞吐量<br>:   CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p><p>并行（Parallel）<br>:   指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p><p>并发（Concurrent）<br>:   指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</p><hr><a id="more"></a><h2 id="垃圾回收器分类"><a href="#垃圾回收器分类" class="headerlink" title="垃圾回收器分类"></a>垃圾回收器分类</h2><h3 id="按照回收线程数分："><a href="#按照回收线程数分：" class="headerlink" title="按照回收线程数分："></a>按照回收线程数分：</h3><p>1、串行垃圾回收器</p><blockquote><p>serial 收集器，serial old 收集器</p></blockquote><p>2、并行垃圾回收器</p><blockquote><p>parNew收集器，Parallel Scavenge，parallel old</p></blockquote><hr><h3 id="按照工作模式划分"><a href="#按照工作模式划分" class="headerlink" title="按照工作模式划分"></a>按照工作模式划分</h3><p>1、独占式垃圾回收器</p><blockquote><p>serial 收集器，serial old 收集器，parNew收集器，Parallel Scavenge，parallel old</p></blockquote><p>2、并发式垃圾回收器</p><blockquote><p>cms</p></blockquote><hr><h3 id="按照工作的内存区间划分："><a href="#按照工作的内存区间划分：" class="headerlink" title="按照工作的内存区间划分："></a>按照工作的内存区间划分：</h3><p>1、新生代</p><blockquote><p>serial， parNew， Parallel Scavenge</p></blockquote><p>2、老生代</p><blockquote><p>serial old， parallel old， cms</p></blockquote><hr><h3 id="按照碎片处理方式划分"><a href="#按照碎片处理方式划分" class="headerlink" title="按照碎片处理方式划分"></a>按照碎片处理方式划分</h3><p>压缩式垃圾回收器</p><blockquote><p>CMS收集器</p></blockquote><pre><code>CMS收集器提供了-XX:+UseCMSCompactAtFullCollection开启碎整理-XX:CMSFullGCsBeforeCompaction，设置执行多少次不压缩的FullGC后，跟着来一次带压缩的</code></pre><p>非压缩式垃圾回收器</p><blockquote><p>serial 收集器，serial old 收集器，parNew收集器，Parallel Scavenge，parallel old</p></blockquote><hr><h3 id="按照回收算法"><a href="#按照回收算法" class="headerlink" title="按照回收算法"></a>按照回收算法</h3><p>1、标记 清除 </p><blockquote><p>cms</p></blockquote><p>2、复制</p><blockquote><p>serial ，parNew， parallel scavenger</p></blockquote><p>3、标记 整理</p><blockquote><p>serial old， parallel old</p></blockquote><hr><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>Parallel Scavenge收集器无法与CMS收集器配合工作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最佳搭配：</span><br><span class="line">ParNew + CMS（GC停顿时间短），</span><br><span class="line">Parallel Scavenge+Parallel Old（吞吐量高）</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 垃圾回收器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的加载机制与对象的实例化</title>
      <link href="/2019/03/26/jvm-class/"/>
      <url>/2019/03/26/jvm-class/</url>
      
        <content type="html"><![CDATA[<p>今天读到周志明的《深入理解java虚拟机》中类加载机制与对象的实例化这块，这本书说实话，还是有点生涩难懂，不过老祖先有祖训：“书读百遍，其义自见”，这句话是对的，我也是时隔2年，重新拜读的。</p><hr><h2 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h2><h3 id="成员变量与静态变量的区别"><a href="#成员变量与静态变量的区别" class="headerlink" title="成员变量与静态变量的区别"></a>成员变量与静态变量的区别</h3><p>静态变量 别名 类变量；成员变量 别名 实例变量<br>类的静态方法和静态变量属于类，作为类型数据保存在方法区，其生命周期取决于类，而实例方法和字段位于Java堆，其生命周期取决于对象的生命周期。</p><hr><h3 id="类初始化与类实例化的区别"><a href="#类初始化与类实例化的区别" class="headerlink" title="类初始化与类实例化的区别"></a>类初始化与类实例化的区别</h3><p>类的初始化是指虚拟机加载CLASS文件到内存中，将Class文件解析成JVM理解的执行指令，将类变量指定初始值，和类的函数方法等存入方法区，将class文件的符号引用转成方法区的直接引用。<br>类初始化之后就可以访问类的静态字段和方法，而访问类的非静态(实例)字段和方法，就需要创建类的对象实例，故<strong>类的实例化是在类的初始化之后，是在堆上创建一个该类的对象</strong></p><hr><a id="more"></a><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><ul><li>装载（加载class解释成虚拟机的方法区的运行期数据结构）</li><li>验证（解析class文件合法性）</li><li>准备(类变量设初始值，而非实例变量)</li><li>解析（符号引用转成直接引用）</li><li>初始化（类变量与static语句初始化）</li><li>使用、卸载</li></ul><h2 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h2><ul><li>虚拟机接受new指令，</li><li>类加载过程，父类静态变量与静态方法块执行完毕，子类静态变量与静态方法执行完毕</li><li>再执行父类的实例变量与构造方法，最后执行子类的实例化变量与构造方法</li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><pre><code class="javascript">public abstract <span class="class"><span class="keyword">class</span> <span class="title">ObjectCreateAEx</span> </span>{    ObjectCreateAEx(){        int a = getAV();        System.out.println(a);    }    public abstract int getAV();}public <span class="class"><span class="keyword">class</span> <span class="title">ObjectCreateBEx</span> <span class="keyword">extends</span> <span class="title">ObjectCreateAEx</span></span>{    private int a = <span class="number">10</span>;    private <span class="keyword">static</span> int b = <span class="number">11</span>;    private <span class="keyword">static</span> final  int c = <span class="number">12</span>;    ObjectCreateBEx(int a){        a = a;    }    @Override    public int  getAV() {       <span class="keyword">return</span> a;    }    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) {        ObjectCreateBEx  aEx =  <span class="keyword">new</span> ObjectCreateBEx(<span class="number">100</span>);    }}</code></pre><p>计算打印的结果是：0。为什么?因为类初始化的是静态变量b，而a是在实例化后才赋值成10的,<br>类实例化的过程是，先构造函数，再实例变量赋值。所以父类构造函数调用子类的变量，取得是子类还未赋值的初始化变量</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://github.com/huangchunwu/own" target="_blank" rel="noopener">示例代码</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类的加载机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM进程占用内存过高排查</title>
      <link href="/2019/03/22/jvmerror/"/>
      <url>/2019/03/22/jvmerror/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="32位的系统-进程内存限制最多2G？"><a href="#32位的系统-进程内存限制最多2G？" class="headerlink" title="32位的系统 进程内存限制最多2G？"></a>32位的系统 进程内存限制最多2G？</h3><p>32 位寻址空间只有 4GB 大小，于是 32 位应用程序进程最大只能用到 4GB 的内存。然而，除了应用程序本身要用内存，操作系统内核也需要使用。应用程序使用的内存空间分为用户空间和内核空间，每个 32 位程序的用户空间可独享前 2GB 空间（指针值为正数），而内核空间为所有进程共享 2GB 空间（指针值为负数）。所以，32 位应用程序实际能够访问的内存地址空间最多只有 2GB。</p><h3 id="JVM进程崩溃？"><a href="#JVM进程崩溃？" class="headerlink" title="JVM进程崩溃？"></a>JVM进程崩溃？</h3><p>1, 当超出JVM的分配的内存时，JAVA进程并不会退出只是结束当前的线程<br>2, 当服务器内存不够时，linux杀死使用内存的一个进程<br>3,  把系统拆分成多个服务部署在同一台机时需要特别注意，JVM启动时分配的内存只是申请（其实体现在VIRT），当一台服务器运行多个JAVA进程时请保留足够的可用内存 (大于分配给各个JVM的进程之和)</p><h3 id="TOP命令参数"><a href="#TOP命令参数" class="headerlink" title="TOP命令参数"></a>TOP命令参数</h3><p>VIRT 虚拟内存中含有共享库、共享内存、栈、堆，所有已申请的总内存空间。<br>RES  是进程正在使用的内存空间(栈、堆)，申请内存后该内存段已被重新赋值。<br>SHR  是共享内存正在使用的空间。<br>SWAP 交换的是已经申请，但没有使用的空间，包括(栈、堆、共享内存)。<br>DATA 是进程栈、堆申请的总空间。</p><a id="more"></a><h3 id="linux内存和JAVA堆中的关系"><a href="#linux内存和JAVA堆中的关系" class="headerlink" title="linux内存和JAVA堆中的关系"></a>linux内存和JAVA堆中的关系</h3><p>JAVA进程内存 = JVM进程内存+heap内存+ 永久代内存+ 本地方法栈内存+线程栈内存 +堆外内存 +socket 缓冲区内存</p><p>RES = JAVA正在存活的内存对象大小 + 未回收的对象大小  + 其它</p><p>VIART= JAVA中申请的内存大小，即 -Xmx  -Xms + 其它</p><p>其它 = 永久代内存+ 本地方法栈内存+线程栈内存 +堆外内存 +socket 缓冲区内存 +JVM进程内存</p><hr><h2 id="怎么排查"><a href="#怎么排查" class="headerlink" title="怎么排查"></a>怎么排查</h2><p>a: 实时查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">找到最耗内存的对象：</span><br><span class="line">jmap -histo 7311（带上:live则表示先进行一次FGC再统计，如jmap -histo:live 7311）</span><br></pre></td></tr></table></figure></p><p>b: 把heap文件dump下来分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=heap.bin 7311 （使用Eclipse mat分析）</span><br></pre></td></tr></table></figure></p><p>统计进程打开的句柄数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /proc/7311/fd |wc -l</span><br></pre></td></tr></table></figure></p><p>统计进程打开的线程数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /proc/7311/task |wc -l</span><br></pre></td></tr></table></figure></p><p>当前jvm线程数统计：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 7311 |grep ‘tid’|wc –l  (linux 64位系统中jvm线程默认栈大小为1MB)</span><br></pre></td></tr></table></figure></p><p>查询堆内存分布情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 7311</span><br></pre></td></tr></table></figure></p><p>查看进程内存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pmap 7311</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一列，内存块起始地址 </span><br><span class="line">第二列，占用内存大小 </span><br><span class="line">第三列，内存权限 </span><br><span class="line">第四列，内存名称，anon表示动态分配的内存，stack表示栈内存 </span><br><span class="line">最后一行，占用内存总大小，请注意，此处为虚拟内存大小，占用的物理内存大小可以通过top查看</span><br></pre></td></tr></table></figure><p>jstat命令查看jvm的GC情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Options，选项，我们一般使用 -gcutil 查看gc情况 </span><br><span class="line">vmid，VM的进程号，即当前运行的java进程号 </span><br><span class="line">interval，间隔时间，单位为秒或者毫秒 </span><br><span class="line">count，打印次数，如果缺省则打印无数次</span><br></pre></td></tr></table></figure><blockquote><p> jstat -gc 7311 5000</p></blockquote><h2 id="JVM调优实战参考"><a href="#JVM调优实战参考" class="headerlink" title="JVM调优实战参考"></a>JVM调优实战参考</h2><hr><p><a href="https://www.analysys.cn/article/detail/20019016" target="_blank" rel="noopener">jvm疯狂吞占内存，罪魁祸首是谁？</a><br><a href="https://jeffinbao.github.io/2016/04/24/20160424-research-on-java-memory-overweighted/" target="_blank" rel="noopener">记一次Java内存占用过大排查</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM调优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>钉钉H5微应用开发总结</title>
      <link href="/2019/03/17/dingdingdev/"/>
      <url>/2019/03/17/dingdingdev/</url>
      
        <content type="html"><![CDATA[<p>今年，我又做了一个钉钉微应用的项目，第一次接触钉钉，把踩过的坑，记录下来，为后人乘凉所用。</p><hr><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>开放平台注册申请权限</li><li>选择钉钉应用类型，创建应用，获取AppKey，AppSecret，CORP_ID，</li><li>准备开发环境 静态页面、JS，CSS放在ngnix，本地接口用tomcat。</li><li>内网穿透，用于开发时候调试钉钉应用</li></ul><a id="more"></a><blockquote><p>减少代码耦合度，我采用前后端分离，没有采用freemaker等模板引擎工具，我将页面与接口放在不同服务器上，那么就有跨域问题，解决方案是ngnix，配置反向代理同个host不同端口，则可以解决JS跨域问题。</p></blockquote><blockquote><p> 钉钉下，有E应用（不成熟），微应用（较成熟）。我用的是相对成熟的微应用。另外应用还分，第三方企业内部应用，企业内部应用，第三方个人应用，移动应用接入。由于我的业务方需求，我选择的企业内部应用，注意看对应的文档，钉钉功能太混杂容易混淆。</p></blockquote><h2 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h2><h3 id="引入JS"><a href="#引入JS" class="headerlink" title="引入JS"></a>引入JS</h3><p>common.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"//g.alicdn.com/dingding/dingtalk-jsapi/2.0.57/dingtalk.open.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="JSAPI免登授权码"><a href="#JSAPI免登授权码" class="headerlink" title="JSAPI免登授权码"></a>JSAPI免登授权码</h3><p>获取当前钉钉登录用户的账号信息，需要通过免登授权码换取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取免登授权码</span></span><br><span class="line">  dd.ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      dd.runtime.permission.requestAuthCode(&#123;</span><br><span class="line">          corpId: _config.corpId,</span><br><span class="line">          onSuccess: <span class="function"><span class="keyword">function</span>(<span class="params">info</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">var</span> _params = &#123;<span class="string">"code"</span>:info.code&#125;;</span><br><span class="line">              tools.getReqData(<span class="string">'/api/dd/getCurrentLoginUser'</span>, _params, getUserCall);<span class="comment">//通过免登授权码获取用户详细信息</span></span><br><span class="line">          &#125;,</span><br><span class="line">          onFail : <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">              alert(<span class="string">'fail: '</span> + <span class="built_in">JSON</span>.stringify(err));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      dd.error(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">          alert(<span class="string">'dd error: '</span> + <span class="built_in">JSON</span>.stringify(err));</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="JSAPI鉴权"><a href="#JSAPI鉴权" class="headerlink" title="JSAPI鉴权"></a>JSAPI鉴权</h3><p>需要用到钉钉的日历控件，组织机构多选弹出框等控件，所以需要鉴权<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//鉴权验证</span></span><br><span class="line">   dd.config(&#123;</span><br><span class="line">       agentId : _config.agentid,</span><br><span class="line">       corpId : _config.corpId,</span><br><span class="line">       timeStamp : _config.timeStamp,</span><br><span class="line">       nonceStr : _config.nonceStr,</span><br><span class="line">       signature : _config.signature,</span><br><span class="line">       jsApiList : [ <span class="string">'runtime.info'</span>, <span class="string">'biz.contact.choose'</span>,</span><br><span class="line">           <span class="string">'device.notification.confirm'</span>, <span class="string">'device.notification.alert'</span>,</span><br><span class="line">           <span class="string">'device.notification.prompt'</span>, <span class="string">'biz.ding.post'</span>,<span class="string">'biz.contact.complexPicker'</span>,</span><br><span class="line">           <span class="string">'biz.util.openLink'</span>,<span class="string">'biz.util.datepicker'</span> ]</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure></p><h3 id="获取TOKEN"><a href="#获取TOKEN" class="headerlink" title="获取TOKEN"></a>获取TOKEN</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在此方法中，为了避免频繁获取access_token，</span></span><br><span class="line"><span class="comment"> * 在距离上一次获取access_token时间在两个小时之内的情况，</span></span><br><span class="line"><span class="comment"> * 将直接从持久化存储中读取access_token</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 因为access_token和jsapi_ticket的过期时间都是7200秒</span></span><br><span class="line"><span class="comment"> * 所以在获取access_token的同时也去获取了jsapi_ticket</span></span><br><span class="line"><span class="comment"> * 注：jsapi_ticket是在前端页面JSAPI做权限验证配置的时候需要使用的</span></span><br><span class="line"><span class="comment"> * 具体信息请查看开发者文档--权限验证配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">static</span> <span class="built_in">String</span> getAccessToken() throws OApiException &#123;</span><br><span class="line">    long curTime = System.currentTimeMillis();</span><br><span class="line">    JSONObject accessTokenValue = (JSONObject) FileUtils.getValue(<span class="string">"accesstoken"</span>, Env.APP_KEY);</span><br><span class="line">    <span class="built_in">String</span> accToken = <span class="string">""</span>;</span><br><span class="line">    JSONObject jsontemp = <span class="keyword">new</span> JSONObject();</span><br><span class="line">    <span class="keyword">if</span> (accessTokenValue == <span class="literal">null</span> || curTime - accessTokenValue.getLong(<span class="string">"begin_time"</span>) &gt;= cacheTime) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServiceFactory serviceFactory = ServiceFactory.getInstance();</span><br><span class="line">            CorpConnectionService corpConnectionService = serviceFactory.getOpenService(CorpConnectionService.class);</span><br><span class="line">            accToken = corpConnectionService.getCorpToken(Env.APP_KEY, Env.APP_SECRET);</span><br><span class="line">            <span class="comment">// save accessToken</span></span><br><span class="line">            JSONObject jsonAccess = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            jsontemp.clear();</span><br><span class="line">            jsontemp.put(<span class="string">"access_token"</span>, accToken);</span><br><span class="line">            jsontemp.put(<span class="string">"begin_time"</span>, curTime);</span><br><span class="line">            jsonAccess.put(Env.APP_KEY, jsontemp);</span><br><span class="line">            <span class="comment">//真实项目中最好保存到数据库中</span></span><br><span class="line">            FileUtils.write2File(jsonAccess, <span class="string">"accesstoken"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accessTokenValue.getString(<span class="string">"access_token"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> accToken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取当前用户信息"><a href="#获取当前用户信息" class="headerlink" title="获取当前用户信息"></a>获取当前用户信息</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据免登授权码查询免登用户userId</span></span><br><span class="line"><span class="comment"> * @param accessToken</span></span><br><span class="line"><span class="comment"> * @param code</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> * @throws Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">static</span> CorpUserBaseInfo getUserInfo(<span class="built_in">String</span> accessToken, <span class="built_in">String</span> code) throws Exception &#123;</span><br><span class="line">    CorpUserService corpUserService = ServiceFactory.getInstance().getOpenService(CorpUserService.class);</span><br><span class="line">    <span class="keyword">return</span> corpUserService.getUserinfo(accessToken, code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="钉钉日历控件"><a href="#钉钉日历控件" class="headerlink" title="钉钉日历控件"></a>钉钉日历控件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   $(<span class="string">"#proBidOpent"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> curDate = (<span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear()) + <span class="string">'-'</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>().getMonth()) + <span class="string">'-'</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>().getDay);</span><br><span class="line">    dd.biz.util.datepicker(&#123;</span><br><span class="line">        format: <span class="string">'yyyy-MM-dd'</span>,<span class="comment">//注意：format只支持android系统规范，即2015-03-31格式为yyyy-MM-dd</span></span><br><span class="line">        value: curDate, <span class="comment">//默认显示日期</span></span><br><span class="line">        onSuccess : <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">            $(t).val(result.value);</span><br><span class="line">            <span class="comment">//onSuccess将在点击完成之后回调</span></span><br><span class="line">            <span class="comment">/*&#123;</span></span><br><span class="line"><span class="comment">             value: "2015-02-10"</span></span><br><span class="line"><span class="comment">             &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;,</span><br><span class="line">        onFail : <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            alert(<span class="built_in">JSON</span>.stringify(err));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="钉钉滑动选择人员控件"><a href="#钉钉滑动选择人员控件" class="headerlink" title="钉钉滑动选择人员控件"></a>钉钉滑动选择人员控件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  $(<span class="string">'#recorderName'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tx = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    dd.biz.contact.complexPicker(&#123;</span><br><span class="line">        title:<span class="string">"备案人员"</span>,            <span class="comment">//标题</span></span><br><span class="line">        corpId:_config.corpId,              <span class="comment">//企业的corpId</span></span><br><span class="line">        multiple:<span class="literal">true</span>,            <span class="comment">//是否多选</span></span><br><span class="line">        limitTips:<span class="string">"超出了"</span>,          <span class="comment">//超过限定人数返回提示</span></span><br><span class="line">        maxUsers:<span class="number">100</span>,            <span class="comment">//最大可选人数</span></span><br><span class="line">        pickedUsers:[],            <span class="comment">//已选用户</span></span><br><span class="line">        pickedDepartments:[],          <span class="comment">//已选部门</span></span><br><span class="line">        disabledUsers:[],            <span class="comment">//不可选用户</span></span><br><span class="line">        disabledDepartments:[],        <span class="comment">//不可选部门</span></span><br><span class="line">        requiredUsers:[],            <span class="comment">//必选用户（不可取消选中状态）</span></span><br><span class="line">        requiredDepartments:[],        <span class="comment">//必选部门（不可取消选中状态）</span></span><br><span class="line">        appId:_config.agentid,              <span class="comment">//微应用的Id</span></span><br><span class="line">        permissionType:<span class="string">"xxx"</span>,          <span class="comment">//可添加权限校验，选人权限，目前只有GLOBAL这个参数</span></span><br><span class="line">        responseUserOnly:<span class="literal">true</span>,        <span class="comment">//返回人，或者返回人和部门</span></span><br><span class="line">        startWithDepartmentId:<span class="number">0</span> ,   <span class="comment">//仅支持0和-1</span></span><br><span class="line">        onSuccess: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(result.selectedCount&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">var</span> empIds = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">var</span> empNames = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt; result.selectedCount;i++)&#123;</span><br><span class="line">                    empIds = empIds + result.users[i].emplId+<span class="string">","</span>;</span><br><span class="line">                    empNames = empNames + result.users[i].name+<span class="string">","</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                empIds = empIds.substring(<span class="number">0</span>,empIds.length<span class="number">-1</span>);</span><br><span class="line">                empNames = empNames.substring(<span class="number">0</span>,empNames.length<span class="number">-1</span>);</span><br><span class="line">                $(tx).val(empNames);</span><br><span class="line">                <span class="keyword">var</span> attr_hidden = $(tx).attr(<span class="string">"attr_hidden"</span>);</span><br><span class="line">                $(<span class="string">"#"</span>+attr_hidden).val(empIds);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;,</span><br><span class="line">        onFail : <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            alert(<span class="built_in">JSON</span>.stringify(err));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://github.com/huangchunwu/myDingding" target="_blank" rel="noopener">开源代码</a></p>]]></content>
      
      
      <categories>
          
          <category> 钉钉开发实录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 钉钉开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近的所思、所感</title>
      <link href="/2019/03/16/myThink/"/>
      <url>/2019/03/16/myThink/</url>
      
        <content type="html"><![CDATA[<p>最近比较烦。 </p><ul><li style="list-style: none"><input type="checkbox" checked> 借了一屁股债，买了一套房，还在交易中。</li><li style="list-style: none"><input type="checkbox" checked> 丈母娘眼睛需要做个小手术，预约了住院时间</li><li style="list-style: none"><input type="checkbox"> 小孩3岁，该是上幼儿园的年纪了，可是没有居住证。</li></ul><hr><ul><li>第一个感触就是，结婚了，你要处理的是二个家庭的问题。</li><li>第二个感触就是，靠技术，不能度过中年危机.</li><li>有个房贷，你开始害怕失业了</li><li>在大公司，认识到自己就是一个螺丝钉，很难挤到中层去</li></ul><a id="more"></a><p>关于本末倒置</p><p>热播剧《都挺好》中有这样一个桥段，小姑凉高二开始做推荐课程，遇到一位老板，<br>老板问他一节课多少钱，总共多长时间学完，<br>小姑凉迷惑的如实回答了，<br>老板说，你知道我花这么长时间上课，耽误我挣多少钱了吗？<br>然后老板问小姑凉，你年纪这么小，挣钱做什么？<br>小姑凉说挣钱去国外留学。<br>老板问，去国外留学做什么？<br>菇凉说，挣大钱，出人头地。<br>老板问，那留学要花多少钱，你得攒多久才能凑满。<br>小姑凉算了算，要10年。<br>老板说，那10年后，就是你攒够钱了，去留学回来，还是个打工赚钱，还是一穷二白。</p>]]></content>
      
      
      <categories>
          
          <category> 经验积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【在线工具】JSON字符串转为javaBean对象</title>
      <link href="/2019/03/13/jsonutil/"/>
      <url>/2019/03/13/jsonutil/</url>
      
        <content type="html"><![CDATA[<p>一款免费的在线的JSON字符串转为javaBean对象工具，提高工作效率，记录一下<br><a id="more"></a></p><p><a href="https://www.bejson.com/json2javapojo/new/" target="_blank" rel="noopener">JSON字符串转为javaBean对象在线工具</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC工具类之exchanger</title>
      <link href="/2019/03/09/exchanger/"/>
      <url>/2019/03/09/exchanger/</url>
      
        <content type="html"><![CDATA[<p>日常开发使用，JUC工具类里面的exchanger使用场景不多，既然看到了就学了一下记一下。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>exchanger 用于二个线程，规定一个交换点，当双方线程到达这个点后，相互交换数据的效果。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>用于2个线程交互数据使用；经典生产消费者</p><a id="more"></a><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * java concurrent 包</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 用于2个线程交互数据使用</span><br><span class="line"> * 规定一个交换点，当双方线程到达这个点后，相互交换数据</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * Created by huangchunwu on 2019/3/4.</span><br><span class="line"> */</span><br><span class="line">public class ExchangeTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testExchange() &#123;</span><br><span class="line">        final Exchanger&lt;Integer&gt; exchanger = new Exchanger&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Runnable r1 = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.print(Thread.currentThread().getName() + &quot;get &quot; + exchanger.exchange(2019));</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Runnable r2 = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.print(Thread.currentThread().getName() + &quot;get &quot; + exchanger.exchange(2018));</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(r1);</span><br><span class="line">        t1.setName(&quot;A&quot;);</span><br><span class="line">        Thread t2 = new Thread(r2);</span><br><span class="line">        t2.setName(&quot;B&quot;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.currentThread().sleep(1000000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://github.com/huangchunwu/own" target="_blank" rel="noopener">示例代码</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal如何防止内存泄漏</title>
      <link href="/2019/02/02/threadlocal/"/>
      <url>/2019/02/02/threadlocal/</url>
      
        <content type="html"><![CDATA[<p> 工作五年了，对ThreadLocal原理还不是很清楚，o(<em>￣︶￣</em>)o。今天来分析下，使用threadLocal时候，导致内存泄漏的原理。</p><hr><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>1、用于存放线程局部变量。<br>2、一个线程都会维护一个threadLocalMap,threadLocal包装成弱引用作       为key，线程局部变量作为value,装在entry数组里面。</p></blockquote><hr><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><blockquote><p>set(T value) 存储线程局部变量值<br>get() 获取线程局部变量值<br>remove() 移除线程局部变量，即entry数组</p></blockquote><hr><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>1、ThreadLocal层面<br> 通常，线程结束了，threadLocal作为弱引用的key，此时key==null,Entry也就被GC了<br>2、ThreadLocalMap层面<br> 如果线程存活比较久，线程局部变量作为value的数量如果超过容量的2/3(没有扩大容量时是10个)，则会触发Entry的回收</p><hr><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>内存泄露<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、如果使用线程池，要注意手动清理threadLocal</span><br><span class="line">2、如果线程消亡了，threadLocal==null,此时entry还是被强引用的话，</span><br><span class="line">   threadLocalMap不会被回收，造成内存泄露</span><br></pre></td></tr></table></figure></p><hr><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1、可以用于单个线程的参数的存储，模板方法的上下文</span><br><span class="line">2、Java7中的SimpleDateFormat不是线程安全的，可以用ThreadLocal来解决这个问题</span><br><span class="line">3、InheritableThreadLocal可以跨线程共享ThreadLocal变量，用于将主线程的变量传递给子线程中例如用户标识（user id）或事务标识（transaction id），但不能是有状态对象，例如 JDBC Connection</span><br></pre></td></tr></table></figure><hr><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://github.com/huangchunwu/own" target="_blank" rel="noopener">示例代码</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Threadlocal </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思维导图在线工具</title>
      <link href="/2019/02/02/swtools/"/>
      <url>/2019/02/02/swtools/</url>
      
        <content type="html"><![CDATA[<p>今天发现一款免费的在线的思维导图工具，蛮不错的，记录一下<br><a id="more"></a></p><p><a href="https://www.processon.com" target="_blank" rel="noopener">思维导图在线工具</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并行计算框架forkJoin框架</title>
      <link href="/2019/01/25/forkjoin/"/>
      <url>/2019/01/25/forkjoin/</url>
      
        <content type="html"><![CDATA[<h2 id="框架思想"><a href="#框架思想" class="headerlink" title="框架思想"></a>框架思想</h2><p>当业务系统遇到要处理大任务的时候，可以拆分成小任务来执行，最后将小任务的执行结果汇总，返回给大任务，简称为“分而治之”，jdk7提供了forkJoin框架，Hadoop提供了MapReduce。</p><hr><h2 id="适合场景"><a href="#适合场景" class="headerlink" title="适合场景"></a>适合场景</h2><blockquote><p>多核CPU服务器<br>CPU密集的应用，<br>并行计算的应用</p></blockquote><hr><a id="more"></a><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><h3 id="forkJoinTask-抽象类"><a href="#forkJoinTask-抽象类" class="headerlink" title="forkJoinTask 抽象类"></a>forkJoinTask 抽象类</h3><p>不直接使用，直接使用以下子类提供的fork与join方法</p><blockquote><p>RecursiveAction 无返回值<br>RecursiveTask 有返回值</p></blockquote><hr><h3 id="forkJoinPool-线程池"><a href="#forkJoinPool-线程池" class="headerlink" title="forkJoinPool 线程池"></a>forkJoinPool 线程池</h3><p>提供了forkJoin线程池。每一个工作线程维护一份双端队列，队列里面存放待执行的任务，线程池内部使用“工作窃取算法”，即工作线程自己的队列任务处理完了，可以“窃取”其他线程的队列的任务去执行，提供的CPU利用率，所以工作线程不要用于IO流操作等超时任务。</p><hr><h3 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h3><p>每一个工作线程维护一份双端队列，当工作线程处理完自己的队列后，会窃取其他线程的队列帮忙处理，充分使用所有线程资源，直到处理完所有的队列，这才是特别的地方。</p><hr><h3 id="fork-Join框架基本模板"><a href="#fork-Join框架基本模板" class="headerlink" title="fork/Join框架基本模板"></a>fork/Join框架基本模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(任务足够小)&#123;</span><br><span class="line">    进行计算；</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    将任务分为两个部分；</span><br><span class="line">    结合两个子任务结果；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 临界值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    private <span class="keyword">static</span> final int THRESHOLD = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    int start=<span class="number">0</span>;</span><br><span class="line">    int end=<span class="number">100000</span>;</span><br><span class="line">    int sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    public CountTask(int start,int end)&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Integer compute() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (end-start&lt;THRESHOLD)&#123;</span><br><span class="line">            <span class="keyword">for</span> (int i=start;i&lt;end;i++)&#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            int middle = (start + end)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            RecursiveTask&lt;Integer&gt; left_task =  <span class="keyword">new</span> CountTask(start,middle);</span><br><span class="line">            RecursiveTask&lt;Integer&gt; right_task =  <span class="keyword">new</span> CountTask(middle,end);</span><br><span class="line"></span><br><span class="line">            invokeAll(left_task,right_task);</span><br><span class="line"></span><br><span class="line">            sum = left_task.join() + right_task.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分而治之</span></span><br><span class="line"><span class="comment"> * forkjoin 线程池是双端队列，采用窃取算法</span></span><br><span class="line"><span class="comment"> * Created by huangchunwu on 2019/1/21.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTaskTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public  <span class="keyword">void</span> testInvokeForkPool()&#123;</span><br><span class="line">        <span class="comment">// 创建一个通用池，这个是jdk1.8提供的功能</span></span><br><span class="line">        ForkJoinPool pool = ForkJoinPool.commonPool();</span><br><span class="line"></span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        ForkJoinTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>,<span class="number">999999999</span>);</span><br><span class="line">        Integer result = (Integer) pool.invoke(task);</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"Fork/join sum: "</span> + result + <span class="string">" in "</span> + (endTime - startTime) + <span class="string">" ms."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public  <span class="keyword">void</span> testsubmitForkPool()&#123;</span><br><span class="line">        <span class="comment">// 创建一个通用池，这个是jdk1.8提供的功能</span></span><br><span class="line">        ForkJoinPool pool = ForkJoinPool.commonPool();</span><br><span class="line"></span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        ForkJoinTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>,<span class="number">999999999</span>);</span><br><span class="line">        pool.submit(task);</span><br><span class="line">        Integer result =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = (Integer) task.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"Fork/join sum: "</span> + result + <span class="string">" in "</span> + (endTime - startTime) + <span class="string">" ms."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/jinggod/p/8490511.html" target="_blank" rel="noopener">Fork-Join分治编程介绍（一）</a><br><a href="https://github.com/huangchunwu/own" target="_blank" rel="noopener">示例源码</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> forkJoin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Guava Cache 学习记录</title>
      <link href="/2019/01/15/guava-cache/"/>
      <url>/2019/01/15/guava-cache/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么使用Guava-Cache？"><a href="#为什么使用Guava-Cache？" class="headerlink" title="为什么使用Guava Cache？"></a>为什么使用Guava Cache？</h2><p>guava cache属于JVM内存的缓存,其实JAVA本地缓存框架有ecache，简单点有HashMap作为缓存容器,那么，为什么推荐用guava cache呢,比如以下：<br>1、设置缓存的过期时间,遵循LRU原则移除过期KEY<br>2、缓存的定期刷新<br>3、如何防止缓存穿透</p><p>如果自己实现起来难度较大，谷歌开发对缓存操作作了封装，方便研发的重心集中在业务处理，无需关心底层实现，无需重复造轮子。</p><p>我们常用的是redis可以实现分布式缓存，为什么推荐用guava cache呢<br>1、同时造成了业务系统 强依赖于网络和redis服务器的稳定性<br>2、网络请求的效率远远没有本地内存快。</p><a id="more"></a><hr><h2 id="哪些场景适合使用Guava-cache"><a href="#哪些场景适合使用Guava-cache" class="headerlink" title="哪些场景适合使用Guava cache"></a>哪些场景适合使用Guava cache</h2><p>通常缓存的用法，先请求本地缓存，如果本地缓存未命中，则去请求DB。<br>Guava cache 是本地缓存，所以适合数据量小的数据量的情况下使用。</p><hr><h2 id="Guava-cache特性"><a href="#Guava-cache特性" class="headerlink" title="Guava cache特性"></a>Guava cache特性</h2><p>1、缓存不会自动刷新，需满足2个条件，<code>过期了</code>，<code>有get请求</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">static ListeningExecutorService executorService =</span><br><span class="line">           MoreExecutors.listeningDecorator(Executors.newSingleThreadExecutor());</span><br><span class="line"></span><br><span class="line">   // remove listener</span><br><span class="line">   static RemovalListener&lt;String, Integer&gt; removalListener = new RemovalListener&lt;String, Integer&gt;() &#123;</span><br><span class="line">       public void onRemoval(RemovalNotification&lt;String, Integer&gt; removal) &#123;</span><br><span class="line">           System.out.println(DateUtils.time() +&quot;cause:&quot; + removal.getCause() + &quot; key:&quot; + removal.getKey() + &quot; value:&quot;</span><br><span class="line">                   + removal.getValue());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   final static LoadingCache&lt;String, Integer&gt; loadingCache = CacheBuilder.newBuilder()</span><br><span class="line">           .maximumSize(10)  //最多存放十个数据</span><br><span class="line">        // .expireAfterWrite(3, TimeUnit.SECONDS)  //缓存200秒</span><br><span class="line">           .refreshAfterWrite(1, TimeUnit.SECONDS)</span><br><span class="line">           .removalListener(removalListener)</span><br><span class="line">           .recordStats()   //开启 记录状态数据功能</span><br><span class="line">           .build(new CacheLoader&lt;String, Integer&gt;() &#123;</span><br><span class="line">               //数据加载，默认返回-1,也可以是查询操作，如从DB查询</span><br><span class="line">               @Override</span><br><span class="line">               public Integer load(String key) throws Exception &#123;</span><br><span class="line">                   System.out.println(DateUtils.time() + &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;load&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);</span><br><span class="line">                   return -1;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               //有些键不需要刷新，并且我们希望刷新是异步完成的</span><br><span class="line">               @Override</span><br><span class="line">               public ListenableFuture&lt;Integer&gt; reload(final String key, final Integer oldValue) &#123;</span><br><span class="line">                   System.out.println(DateUtils.time() + &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;reload&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);</span><br><span class="line">                   // we need to load new values asynchronously, so that calls to read values from the cache don&apos;t block</span><br><span class="line">                   ListenableFuture&lt;Integer&gt; listenableFuture = executorService.submit(new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">                       @Override</span><br><span class="line">                       public Integer call() throws Exception &#123;</span><br><span class="line">                           try &#123;</span><br><span class="line">                               Integer value = load(key);</span><br><span class="line">                               return value;</span><br><span class="line">                           &#125; catch (Exception ex) &#123;</span><br><span class="line">                               return oldValue;</span><br><span class="line">                           &#125; finally &#123;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br><span class="line">                   return listenableFuture;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure></p><p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sun Jan 20 18:55:46 CST 2019&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;put&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">Sun Jan 20 18:55:50 CST 2019&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;get&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">Sun Jan 20 18:55:50 CST 2019&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;reload&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">Sun Jan 20 18:55:50 CST 2019&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;load&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">Sun Jan 20 19:11:37 CST 2019&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;cause:REPLACED key:1 value:1</span><br></pre></td></tr></table></figure></p><p>由上述程序执行结果，可以看出，cache的key进行put后4S没有reload，第5S的时候get请求后，reload才开始。</p><p>2、Guava Cache的load方法不能返回null，否则抛异常，Guava Cache的get方法先在本地缓存中取，如果不存在，则会触发load方法。但load方法不能返回null。 </p><hr><h2 id="Guava-cache-有什么替代品"><a href="#Guava-cache-有什么替代品" class="headerlink" title="Guava cache 有什么替代品"></a>Guava cache 有什么替代品</h2><p>Caffeine 宣称拥有比 Guava Cache 高几倍的读写效率</p><hr><h2 id="Guava-cache使用步骤"><a href="#Guava-cache使用步骤" class="headerlink" title="Guava cache使用步骤"></a>Guava cache使用步骤</h2><h3 id="引入maven的POM"><a href="#引入maven的POM" class="headerlink" title="引入maven的POM"></a>引入maven的POM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;19.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="Guava-Cache初始化"><a href="#Guava-Cache初始化" class="headerlink" title="Guava Cache初始化"></a>Guava Cache初始化</h3><h4 id="Cache-Callable"><a href="#Cache-Callable" class="headerlink" title="Cache Callable"></a>Cache Callable</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final static Cache&lt;Integer, String&gt; cache = CacheBuilder.newBuilder()</span><br><span class="line">           //设置cache的初始大小为10，要合理设置该值</span><br><span class="line">           .initialCapacity(10)</span><br><span class="line">           //设置并发数为5，即同一时间最多只能有5个线程往cache执行写入操作</span><br><span class="line">           .concurrencyLevel(5)</span><br><span class="line">           //设置cache中的数据在写入之后的存活时间为10秒</span><br><span class="line">           .expireAfterWrite(10, TimeUnit.SECONDS)</span><br><span class="line">           //构建cache实例</span><br><span class="line">           .build();</span><br></pre></td></tr></table></figure><h4 id="LoadingCache"><a href="#LoadingCache" class="headerlink" title="LoadingCache"></a>LoadingCache</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final static LoadingCache&lt;String, Integer&gt; cache = CacheBuilder.newBuilder()</span><br><span class="line">           .maximumSize(10)  //最多存放十个数据</span><br><span class="line">           .expireAfterWrite(10, TimeUnit.SECONDS)  //缓存200秒</span><br><span class="line">           .recordStats()   //开启 记录状态数据功能</span><br><span class="line">           .build(new CacheLoader&lt;String, Integer&gt;() &#123;</span><br><span class="line">               //数据加载，默认返回-1,也可以是查询操作，如从DB查询</span><br><span class="line">               @Override</span><br><span class="line">               public Integer load(String key) throws Exception &#123;</span><br><span class="line">                   return -1;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure><h3 id="Guava-Cache常用方法"><a href="#Guava-Cache常用方法" class="headerlink" title="Guava Cache常用方法"></a>Guava Cache常用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 该接口的实现被认为是线程安全的，即可在多线程中调用 </span><br><span class="line"> * 通过被定义单例使用 </span><br><span class="line"> */  </span><br><span class="line">public interface Cache&lt;K, V&gt; &#123;  </span><br><span class="line"></span><br><span class="line">  /** </span><br><span class="line">   * 通过key获取缓存中的value，若不存在直接返回null </span><br><span class="line">   */  </span><br><span class="line">  V getIfPresent(Object key);  </span><br><span class="line"></span><br><span class="line">  /** </span><br><span class="line">   * 通过key获取缓存中的value，若不存在就通过valueLoader来加载该value </span><br><span class="line">   * 整个过程为 &quot;if cached, return; otherwise create, cache and return&quot; </span><br><span class="line">   * 注意valueLoader要么返回非null值，要么抛出异常，绝对不能返回null </span><br><span class="line">   */  </span><br><span class="line">  V get(K key, Callable&lt;? extends V&gt; valueLoader) throws ExecutionException;  </span><br><span class="line"></span><br><span class="line">  /** </span><br><span class="line">   * 添加缓存，若key存在，就覆盖旧值 </span><br><span class="line">   */  </span><br><span class="line">  void put(K key, V value);  </span><br><span class="line"></span><br><span class="line">  /** </span><br><span class="line">   * 删除该key关联的缓存 </span><br><span class="line">   */  </span><br><span class="line">  void invalidate(Object key);  </span><br><span class="line"></span><br><span class="line">  /** </span><br><span class="line">   * 删除所有缓存 </span><br><span class="line">   */  </span><br><span class="line">  void invalidateAll();  </span><br><span class="line"></span><br><span class="line">  /** </span><br><span class="line">   * 执行一些维护操作，包括清理缓存 </span><br><span class="line">   */  </span><br><span class="line">  void cleanUp();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存回收"><a href="#缓存回收" class="headerlink" title="缓存回收"></a>缓存回收</h2><p><code>基于容量回收</code> </p><p>CacheBuilder.maximumSize(long)</p><p><code>定时回收</code>   </p><p>expireAfterAccess(long, TimeUnit) -&gt; KEY在一定时间内没有读写，则失效，下次读取直接load（）中取</p><p>expireAfterWrite(long, TimeUnit) -&gt; 避免了缓存穿透的问题，保证了数据的实时性，牺牲的是性能，当数据expire的时候，大量get请求过来的时候，只有一个请求会去load（）数据，而没有更新完成之前，其他全部请求会被block（每个线程都要轮询的判断lock状态）</p><p><code>基于引用回收</code> </p><p>CacheBuilder.weakKeys()：使用弱引用存储键<br>               CacheBuilder.weakValues()：使用弱引用存储值<br>               CacheBuilder.softValues()：使用软引用存储值。</p><hr><h2 id="缓存刷新"><a href="#缓存刷新" class="headerlink" title="缓存刷新"></a>缓存刷新</h2><p>refreshAfterWrite(long, TimeUnit) -&gt; 机制是并非超时时间到就自动刷新，而是请求 get的时候才会触发refresh，默认refresh是同步请求新值，可以重新refresh方法改成异步。如果有大量并发请求的时候，只会有一个请求get-&gt;reload同步执行，其他线程返回旧值.</p><ul><li><p>弊端<br>吞吐量低的应用，在超过过期时间时，大量并发get请求时，大部分拿到的是很久前的旧值，导致数据脏读。</p></li><li><p>如何解决？<br>可以同时使用expireAfterWrite设置key过期时间，比如每2s刷新一次新值，设置expireAfterWrite为5s为过期时间，则当key值5s没有访问的话，则第5s的时候强制取load新值，解决了脏读问题，也同时避免了缓存穿透问题。</p></li></ul><hr><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://github.com/ben-manes/caffeine" target="_blank" rel="noopener">Caffeine github</a><br><a href="https://github.com/huangchunwu/own" target="_blank" rel="noopener">示例代码</a></p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> Guava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo主题优化</title>
      <link href="/2019/01/11/hexo-improve/"/>
      <url>/2019/01/11/hexo-improve/</url>
      
        <content type="html"><![CDATA[<p>hexo搭建好博客后，需要给博客的装扮下，记录一下一些主题优化技巧<br><a id="more"></a></p><h2 id="安装文章计数插件WordCount"><a href="#安装文章计数插件WordCount" class="headerlink" title="安装文章计数插件WordCount"></a>安装文章计数插件WordCount</h2><p>第一步：在blog根目录下，执行以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure></p><hr><p>第二步：修改配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 开启字数统计</span><br><span class="line">word_count: true</span><br></pre></td></tr></table></figure></p><hr><p>第三步：修改主题 swig 布局</p><p>找到<code>themes/next/layout/_macro/post.swig</code>文件，修改【字数统计】，找到如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span title=&quot;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&quot;&gt;</span><br><span class="line">    &#123;&#123; wordcount(post.content) &#125;&#125;字</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p>同理，我们修改【阅读时长】，修改后如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span title=&quot;&#123;&#123; __(&apos;post.min2read&apos;) &#125;&#125;&quot;&gt;</span><br><span class="line">    &#123;&#123; min2read(post.content) &#125;&#125; 分钟</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><h2 id="增加站内搜索"><a href="#增加站内搜索" class="headerlink" title="增加站内搜索"></a>增加站内搜索</h2><p>第一步：在blog根目录下，执行以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure></p><p>第二步：编辑站点配置文件，新增以下内容到任意位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></p><p>第三步：接着修改主题配置文件_config.yml为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">enable: true</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBatch+MYSQL仓库+运维监控后台项目记录</title>
      <link href="/2019/01/11/springbatch/"/>
      <url>/2019/01/11/springbatch/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Spring Batch 是一款轻量级地适合企业级应用的批处理框架，值得注意的是，不同于其他调度框架，Spring Batch不提供调度功能。</p><hr><h3 id="批处理过程"><a href="#批处理过程" class="headerlink" title="批处理过程"></a>批处理过程</h3><p>批处理可以分为以下几个步骤：</p><ol><li>读取数据</li><li>按照业务处理数据</li><li>归档数据的过程</li></ol><hr><h3 id="Spring-Batch给我们提供了什么？"><a href="#Spring-Batch给我们提供了什么？" class="headerlink" title="Spring Batch给我们提供了什么？"></a>Spring Batch给我们提供了什么？</h3><ol><li>统一的读写接口 </li><li>丰富的任务处理方式</li><li>灵活的事务管理及并发处理 </li><li>日志、监控、任务重启与跳过等特性 </li></ol><hr><a id="more"></a><h3 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h3><table><thead><tr><th>名称</th><th style="text-align:right">用途</th></tr></thead><tbody><tr><td>JobRepository</td><td style="text-align:right">用于注册和存储Job的容器</td></tr><tr><td>JobLauncher</td><td style="text-align:right">用于启动Job</td></tr><tr><td>Job</td><td style="text-align:right">实际要执行的作业，包含一个或多个step</td></tr><tr><td>step</td><td style="text-align:right">步骤，批处理的步骤一般包含ItemReader, ItemProcessor, ItemWriter</td></tr><tr><td>ItemReader</td><td style="text-align:right">从给定的数据源读取item</td></tr><tr><td>ItemProcessor</td><td style="text-align:right">在item写入数据源之前进行数据整理</td></tr><tr><td>ItemWriter</td><td style="text-align:right">把Chunk中包含的item写入数据源。</td></tr><tr><td>Chunk</td><td style="text-align:right">数据块，给定数量的item集合，让item进行多次读和处理，当满足一定数量的时候再一次写入。</td></tr><tr><td>TaskLet</td><td style="text-align:right">子任务表， step的一个事务过程，包含重复执行，同步/异步规则等。</td></tr></tbody></table><hr><h3 id="job-step-tasklet-和-chunk-关系"><a href="#job-step-tasklet-和-chunk-关系" class="headerlink" title="job, step, tasklet 和 chunk 关系"></a>job, step, tasklet 和 chunk 关系</h3><p>一个job对应至少一个step，一个step对应0或者1个TaskLet，一个taskLet对应0或者1个Chunk<br><img src="http://static.bookstack.cn/projects/SpringBatchReferenceCN/01_introduction/fig3-chunks.png" alt="我的头像"></p><hr><h3 id="实战：批处理excel插入数据库"><a href="#实战：批处理excel插入数据库" class="headerlink" title="实战：批处理excel插入数据库"></a>实战：批处理excel插入数据库</h3><h4 id="定义数据仓库"><a href="#定义数据仓库" class="headerlink" title="定义数据仓库"></a>定义数据仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 内存仓库  --&gt;</span><br><span class="line">  &lt;!--&lt;bean id=&quot;jobRepository&quot; class=&quot;org.springframework.batch.core.repository.support.MapJobRepositoryFactoryBean&quot;/&gt;--&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 数据库仓库  --&gt;</span><br><span class="line">  &lt;batch:job-repository id=&quot;jobRepository&quot; data-source=&quot;dataRepDruidDataSource&quot;</span><br><span class="line">                        isolation-level-for-create=&quot;SERIALIZABLE&quot; transaction-manager=&quot;transactionManager&quot;</span><br><span class="line">                        table-prefix=&quot;BATCH_&quot; max-varchar-length=&quot;1000&quot; /&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="定义启动器"><a href="#定义启动器" class="headerlink" title="定义启动器"></a>定义启动器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 作业调度器，用来启动job,引用作业仓库 --&gt;</span><br><span class="line">&lt;bean id=&quot;jobLauncher&quot;</span><br><span class="line">      class=&quot;org.springframework.batch.core.launch.support.SimpleJobLauncher&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;jobRepository&quot; ref=&quot;jobRepository&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="定义JOB"><a href="#定义JOB" class="headerlink" title="定义JOB"></a>定义JOB</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;batch:job id=&quot;userBatchJobName&quot; restartable=&quot;true&quot;&gt;</span><br><span class="line">    &lt;batch:step id=&quot;userStep&quot;&gt;</span><br><span class="line">        &lt;batch:tasklet allow-start-if-complete=&quot;false&quot;</span><br><span class="line">                       start-limit=&quot;1&quot; task-executor=&quot;taskExecutor&quot; throttle-limit=&quot;5&quot;&gt;</span><br><span class="line">            &lt;batch:chunk reader=&quot;userReader&quot; writer=&quot;userWriter&quot;</span><br><span class="line">                         processor=&quot;userProcessor&quot; commit-interval=&quot;5&quot; retry-limit=&quot;10&quot;&gt;</span><br><span class="line">                &lt;batch:retryable-exception-classes&gt;</span><br><span class="line">                    &lt;batch:include class=&quot;org.springframework.dao.DuplicateKeyException&quot;/&gt;</span><br><span class="line">                    &lt;batch:include class=&quot;java.sql.BatchUpdateException&quot;/&gt;</span><br><span class="line">                    &lt;batch:include class=&quot;java.sql.SQLException&quot;/&gt;</span><br><span class="line">                &lt;/batch:retryable-exception-classes&gt;</span><br><span class="line">            &lt;/batch:chunk&gt;</span><br><span class="line">        &lt;/batch:tasklet&gt;</span><br><span class="line">    &lt;/batch:step&gt;</span><br><span class="line">&lt;/batch:job&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;taskExecutor&quot;</span><br><span class="line">      class=&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;&gt;</span><br><span class="line">    &lt;!-- 线程池维护线程的最少数量 --&gt;</span><br><span class="line">    &lt;property name=&quot;corePoolSize&quot; value=&quot;100&quot;/&gt;</span><br><span class="line">    &lt;!-- 线程池维护线程所允许的空闲时间 --&gt;</span><br><span class="line">    &lt;property name=&quot;keepAliveSeconds&quot; value=&quot;30000&quot;/&gt;</span><br><span class="line">    &lt;!-- 线程池维护线程的最大数量 --&gt;</span><br><span class="line">    &lt;property name=&quot;maxPoolSize&quot; value=&quot;300&quot;/&gt;</span><br><span class="line">    &lt;!-- 线程池所使用的缓冲队列 --&gt;</span><br><span class="line">    &lt;property name=&quot;queueCapacity&quot; value=&quot;100&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="定义ItemReader"><a href="#定义ItemReader" class="headerlink" title="定义ItemReader"></a>定义ItemReader</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;bean id=&quot;userReader&quot; class=&quot;org.springframework.batch.item.file.FlatFileItemReader&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;lineMapper&quot; ref=&quot;lineMapper&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;resource&quot; value=&quot;classpath:message/batch-data-source.csv&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 将每行映射成对象 --&gt;</span><br><span class="line">   &lt;bean id=&quot;lineMapper&quot; class=&quot;org.springframework.batch.item.file.mapping.DefaultLineMapper&quot;&gt;</span><br><span class="line">       &lt;property name=&quot;lineTokenizer&quot;&gt;</span><br><span class="line">           &lt;bean class=&quot;org.springframework.batch.item.file.transform.DelimitedLineTokenizer&quot;&gt;</span><br><span class="line">               &lt;property name=&quot;delimiter&quot; value=&quot;,&quot;/&gt;&lt;!-- 根据某种分隔符分割 --&gt;</span><br><span class="line">               &lt;property name=&quot;names&quot; value=&quot;id,name&quot; /&gt;</span><br><span class="line">           &lt;/bean&gt;</span><br><span class="line">       &lt;/property&gt;</span><br><span class="line">       &lt;property name=&quot;fieldSetMapper&quot;&gt;&lt;!-- 将拆分后的字段映射成对象 --&gt;</span><br><span class="line">           &lt;bean class=&quot;com.hcw.core.batch.UserFieldSetMapper&quot; /&gt;</span><br><span class="line">       &lt;/property&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="定义ItemWriter"><a href="#定义ItemWriter" class="headerlink" title="定义ItemWriter"></a>定义ItemWriter</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;bean id=&quot;userWriter&quot; class=&quot;com.hcw.core.batch.MyBatchItemWriter&quot; scope=&quot;step&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;statementId&quot; value=&quot;com.hcw.core.batch.dao.UserToMapper.batchInsert&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactoryTo&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="定义ItemProcessor"><a href="#定义ItemProcessor" class="headerlink" title="定义ItemProcessor"></a>定义ItemProcessor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userProcessor&quot; class=&quot;com.hcw.core.batch.UserItemProcessor&quot;/&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="定义jobRepository的数据源"><a href="#定义jobRepository的数据源" class="headerlink" title="定义jobRepository的数据源"></a>定义jobRepository的数据源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  &lt;bean id=&quot;dataRepDruidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span><br><span class="line">  init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">&lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.mysql.rep.connection.url&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.mysql.rep.connection.username&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.mysql.rep.connection.password&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;filters&quot; value=&quot;$&#123;jdbc.mysql.rep.connection.filters&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;maxActive&quot; value=&quot;$&#123;jdbc.mysql.rep.connection.maxActive&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;initialSize&quot; value=&quot;$&#123;jdbc.mysql.rep.connection.initialSize&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;maxWait&quot; value=&quot;$&#123;jdbc.mysql.rep.connection.maxWait&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;minIdle&quot; value=&quot;$&#123;jdbc.mysql.rep.connection.minIdle&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;timeBetweenEvictionRunsMillis&quot;</span><br><span class="line">  value=&quot;$&#123;jdbc.mysql.rep.connection.timeBetweenEvictionRunsMillis&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;minEvictableIdleTimeMillis&quot;</span><br><span class="line">  value=&quot;$&#123;jdbc.mysql.rep.connection.minEvictableIdleTimeMillis&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;validationQuery&quot;</span><br><span class="line">  value=&quot;$&#123;jdbc.mysql.rep.connection.validationQuery&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;testWhileIdle&quot;</span><br><span class="line">  value=&quot;$&#123;jdbc.mysql.rep.connection.testWhileIdle&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;testOnBorrow&quot; value=&quot;$&#123;jdbc.mysql.rep.connection.testOnBorrow&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;testOnReturn&quot; value=&quot;$&#123;jdbc.mysql.rep.connection.testOnReturn&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;poolPreparedStatements&quot;</span><br><span class="line">  value=&quot;$&#123;jdbc.mysql.rep.connection.poolPreparedStatements&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;maxPoolPreparedStatementPerConnectionSize&quot;</span><br><span class="line">  value=&quot;$&#123;jdbc.mysql.rep.connection.maxPoolPreparedStatementPerConnectionSize&#125;&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h4 id="启动JOB"><a href="#启动JOB" class="headerlink" title="启动JOB"></a>启动JOB</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动tomcat,打开启动页面</span><br></pre></td></tr></table></figure><p> <img src="https://upload-images.jianshu.io/upload_images/3666580-7ef9722ce9bed1bf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我的头像"></p><hr><h3 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h3><p><a href="https://github.com/huangchunwu/batch-framework" target="_blank" rel="noopener">batch-framework</a></p><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.bookstack.cn/read/SpringBatchReferenceCN/README.md" target="_blank" rel="noopener">SpringBatch 中文文档</a></p>]]></content>
      
      
      <categories>
          
          <category> SpringBatch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 批处理 </tag>
            
            <tag> SpringBatch </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018，这一年</title>
      <link href="/2019/01/01/summary/"/>
      <url>/2019/01/01/summary/</url>
      
        <content type="html"><![CDATA[<p>引用习大大的祝贺词中的一句”岁月不居，时节如流”，18年就这样过去了，总结一下这年的收获。</p><h3 id="关于读书，多读比不读好"><a href="#关于读书，多读比不读好" class="headerlink" title="关于读书，多读比不读好"></a>关于读书，多读比不读好</h3><p>这一年，很庆幸的是，我认识了很上进的同事，他对我的影响是让我开始认识到看书的重要性，开始学会在书里寻找价值与智慧。今年我看了32本书，我也不记得自己还记得几个句子，又或者对我带来多大的影响，知乎上也有人提到“<strong>经常看书的人和不看书的人有什么区别</strong>”，我当时是这样回答的：</p><blockquote><p>从我身边的例子来说，有位同事，大学不务正业，泡在金庸武侠世界里，连书中的某段武林秘籍口诀也能倒背如流,当然，他也涉及其它领域。跟他对话，他猛不丁get到一个念头，帮你把你的处境与书中某个人的遭遇相关联,并引出解决方案，这时候你就能领略到读书的用处了，书中记录的是过来人的生活经验，会帮助你解决目前的问题。</p></blockquote><p>就我的感受是自己读完一本本书后，内心很充实，生活中有些问题能从书中找到答案，思想变得更加豁达了，而没有像以前看问题那么局面，自然比以前少发牢骚了，生活也更积极了。</p><a id="more"></a><h3 id="关于工作：“凑合着”做，“凑合着”过，把自己也“凑合着”活了"><a href="#关于工作：“凑合着”做，“凑合着”过，把自己也“凑合着”活了" class="headerlink" title="关于工作：“凑合着”做，“凑合着”过，把自己也“凑合着”活了"></a>关于工作：“凑合着”做，“凑合着”过，把自己也“凑合着”活了</h3><p>刚工作那会，多加班一个小时，都觉得自己吃亏了，如果再对比下别人家的公司加班晚餐与加班费，心里戾气就更严重了，对待工作也消极，演变成了“凑合”。现在仔细想想，”凑合”在我生活中扮演的戏份真的很多，学业上凑合着，工作上凑合着，说到底是对自己凑合着。在公司的每一分一秒，都是自己参与，都属于自己“刻意练习”的机会，可以想成是公司提供的带薪培训的一个很好的平台。我觉得，思想转变了，态度自然就能转变，我就会往好的方向走。</p><h3 id="关于生活：有想法，撸起袖子，去做；而想得多而畏惧不做"><a href="#关于生活：有想法，撸起袖子，去做；而想得多而畏惧不做" class="headerlink" title="关于生活：有想法，撸起袖子，去做；而想得多而畏惧不做"></a>关于生活：有想法，撸起袖子，去做；而想得多而畏惧不做</h3><p>现如今，逃离北上广的人太多了，18年这一年，在上海，作为外地人，我需要为自己留在上海做一些努力。儿子二岁了，面临上幼儿园的问题，外地人上本地幼儿园需要居住证积分，我办了居住证、辗转2次办成了积分。为了以后出行的方便，我把驾照也考了，就不提我苦逼的考了一年的经过了。</p>]]></content>
      
      
      <categories>
          
          <category> 经验积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结合项目，谈谈软件设计原则</title>
      <link href="/2018/12/20/softdesign/"/>
      <url>/2018/12/20/softdesign/</url>
      
        <content type="html"><![CDATA[<p>从事开发这么多年，陆陆续续开发了N个系统了。对软件设计原则，一直没有认真深入的探讨过，当熟读这些原则，结合项目，发现很多违背设计的地方，作为优秀的研发，应该早点跟三字经一样熟读这些原则才对啊。下面我结合最近的项目谈谈自己的见解。</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>官方解释 对扩展是开放的，对修改是关闭的。<br>简单地说，就是你要提供这样的函数方法或者类，你可以进行重载，复写，但是不需要修改。例如，刚开始，火车票电子票出票流程，我在controller层调用business层提供的出票方法。设计的时候，预测到后期还有其他票种，我抽象出一个IOccupyBusiness接口，里面就一个请求占位方法，实现该接口新建实现类EticketOccupyBusiness，在occupy（）写电子票的业务。<br>过了不久，产品提了一个配送票的出票需求，我只需要添加一个实现IOccupyBusiness的实现类DeliveryOccupyBusiness，在occupy（）写配送票的业务，我并没有修改已有类，和方法，复合了开闭原则。</p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>客户端不应该依赖它不需要的接口；<br>一个类对另一个类的依赖应该建立在最小的接口上。<br>简单说，不要给调用方暴露它不需要调用的方法。<br>还拿上述的例子，如果遵循单一职责原则，请求占位，与占位反馈，可以设计成同个接口的不同方法。如果需求是这样的，配送票的占位是虚占，不需要耗时的请求12306实占，所以可以占位接口设计成同步反馈结果，则没有异步反馈的方法。那么配送票的实现类就多暴露出一个占位反馈的方法，不符合接口隔离原则，于是我又将占位接口，粒度细化了，分占位请求接口，占位反馈接口。这样，占位的实现类就不会实现多余的接口了。</p><a id="more"></a><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>官方定义：有且仅有一个让类变化的原因。<br>通俗地说，就是一个类只负责一个职责，比如上面我们谈到的，占位的类，不能同时有出票的功能。<br>单一职责与接口隔离原则有点类似，单一职责偏向于职能，接口隔离偏向于接口粒度。</p><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>官方定义：所以引用基类的地方必须透明的使用子类对象<br>通俗地说，就是子类可以扩展父类的功能，但不能改变父类的功能，即不能重载、复写父类的方法</p><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>官方定义：一个对象应该对其他对象保持最少的了解</p><h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>官方定义 译文：<br>高层模块不应该依赖于低层模块，它们应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p><p>基于以上学习，我在项目里面实现了这样类图<br><img src="https://upload-images.jianshu.io/upload_images/3666580-199028910dc13372.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我的头像"></p>]]></content>
      
      
      <categories>
          
          <category> 经验积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring声明式事务失效的分析过程</title>
      <link href="/2018/12/16/aop/"/>
      <url>/2018/12/16/aop/</url>
      
        <content type="html"><![CDATA[<h3 id="问题的背景"><a href="#问题的背景" class="headerlink" title="问题的背景"></a>问题的背景</h3><p>在途牛，庆幸的是遇到了几个很正面的人，我也是从阅读其中一位同事的博客才发现了spring声明式事务的这个坑，说实话，我平时开发很少用事务，因为不好控制粒度，事务也是高并发的绊脚石。</p><hr><h3 id="问题的现象"><a href="#问题的现象" class="headerlink" title="问题的现象"></a>问题的现象</h3><p>为了理解方便，下面我用伪代码说明问题详细<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Class exampleService&#123;</span><br><span class="line">    <span class="comment">//不加事务，本身不需要事务介入</span></span><br><span class="line">   public <span class="keyword">void</span> methodA（）&#123;</span><br><span class="line">      <span class="comment">//耗时操作</span></span><br><span class="line">      ······</span><br><span class="line">     <span class="comment">//调用B</span></span><br><span class="line">      methodB（）；</span><br><span class="line">      ······</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//声明了事务</span></span><br><span class="line">   @Transactional </span><br><span class="line">   public <span class="keyword">void</span> methodB（）&#123;</span><br><span class="line">      insert();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"操作db失败"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行完代码后，现象是发现methodB的插入的数据没有回滚，像我一样不知道的同学就纳闷了，下面来具体分析下为啥出现事务无效的现象。</p><hr><a id="more"></a><h3 id="问题的分析"><a href="#问题的分析" class="headerlink" title="问题的分析"></a>问题的分析</h3><p>这里来复习一下spring的声明式事务，无非就是spring的二大核心之一：AOP。</p><blockquote><p>AOP的实现原理是java的动态代理。</p></blockquote><blockquote><p>spring实现动态代理有二种方式，其中一个就是cglib，另一个是jdk代理。</p></blockquote><blockquote><p>cglib的原理是jvm调用native方法即ASM，操作class字节码另生成代理类。</p></blockquote><blockquote><p>AOP注解的方法，生成的代理类，并在方法执行前，加入事务的开启，执行后加入事务提交操作</p></blockquote><p>基于这些认知，我们看spring的声明式事务为什么失效。<br>exampleService有二个方法：methodA 是普通方法，methodB是另一个声明了事务方法，class编译出了一个AOP代理类exampleServiceProxy,<br>上述出现问题的调用关系是：</p><pre><code>exampleService.methodA（）调用的是内部方法exampleService.methodB().由此看出methodB并没有被Proxy类通知到。</code></pre><p>正确的调用关系是：</p><pre><code>exampleServiceProxy.methodA()--&gt;exampleServiceProxy.methodB().</code></pre><hr><h3 id="怎么避免此类问题"><a href="#怎么避免此类问题" class="headerlink" title="怎么避免此类问题"></a>怎么避免此类问题</h3><p>知道了原理，我们解决此类问题的方法，要么是新建一个类并将methodB移进来。<br>要么是用编程式事务。</p><hr><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><blockquote><p>说下最近发生的事情，不喜跳过。这段时间工作比较忙，每天有6个小时的有效工作时间，在和南京总部的度假团队，一起开发火车票改签项目，说下这个项目的感受，又是一堆的CURD，这也是敲业务代码的弊端。我想避免温水煮青蛙，突破一下自己，改变了以往的开发习惯，先把以前大冰哥的改签代码，用Visio将业务流程画了一遍，我也不清楚这样有什么好处，有个“上海交大”的同事告诉我这样用处大，只能自己体会，我想人家那么优秀的学历说的话总归有点道理的。等我画完整个流程图后，渐渐的有了点启发，一边心里骂着之前代码结构的设计，一边寻思着开始代码的重构,目前正在紧张的开发中。回过头来想画流程图的好处，我就觉得，看代码的速度放慢了，思考空间也更大了些，于是启发就更多了些。</p></blockquote><p>参考资料：<br><a href="http://www.cnblogs.com/nnngu/p/8627662.html" target="_blank" rel="noopener">Spring的编程式事务和声明式事务</a><br><a href="https://www.cnblogs.com/lcngu/p/5339555.html" target="_blank" rel="noopener">Spring aop的实现原理</a><br><a href="https://www.cnblogs.com/flyingeagle/articles/7102282.html" target="_blank" rel="noopener">Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring声明式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐适合敲代码时候听的空灵音乐</title>
      <link href="/2018/12/16/music/"/>
      <url>/2018/12/16/music/</url>
      
        <content type="html"><![CDATA[<p>日常时间大多数都在敲代码中，当周围环境比较纷杂吵闹，又或者内心比较杂乱烦躁的时候，我都会放上一小段音乐来平复一下自己，通常我会听一些轻音乐，我喜欢青山流水的旋律，或者简简单单的下雨的声音，个人觉得很适合敲代码的时候听。</p><p>现在流行的歌手，参差不齐，商业化向导向的市场已经很难诞生出一个纯粹做音乐的人了，如果听音乐，我个人建议听像朴树、许巍这样的灵魂歌者，他们的音乐简简单单是自己某个阶段的内心表达。</p><p><strong>轻音乐，我建议听下久石让的，最近发现班得瑞的音乐也很好听，推荐下。</strong></p><p><a href="https://www.bandari.net/play" target="_blank" rel="noopener">点击听《班得瑞的轻音乐》</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发调试远程连接设备</title>
      <link href="/2018/12/02/adb/"/>
      <url>/2018/12/02/adb/</url>
      
        <content type="html"><![CDATA[<p>最近在做一个Android-PAD项目，之前本地调试，基本靠sdk模拟器，或者数据线连接手机，李老板教了我新招，可以远程连接设备进行调试，即远程adb。</p><hr><p>前提条件：一台Android设备，并且ROOT</p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">su</span><br><span class="line">setprop service.adb.tcp.port <span class="number">9999</span></span><br><span class="line">stop adbd</span><br><span class="line">start adbd</span><br><span class="line">netstat<span class="comment">#看下adb端口是否打开</span></span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown编辑器</title>
      <link href="/2018/12/02/markdown/"/>
      <url>/2018/12/02/markdown/</url>
      
        <content type="html"><![CDATA[<p>hexo博客搭建好了，可以开始写文章了，所谓“工欲善其事必先利其器”，推荐在线<a href="https://www.zybuluo.com/mdeditor#1356808" target="_blank" rel="noopener">MarkDown编辑器</a>，可以立即预览文章样式。</p>]]></content>
      
      
      <categories>
          
          <category> 搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+GitHub搭建个人博客</title>
      <link href="/2018/12/01/hello-world/"/>
      <url>/2018/12/01/hello-world/</url>
      
        <content type="html"><![CDATA[<hr><p>做IT的没有一个自己的博客，不像话，于是现学现卖搭建了这个博客，记录下来，种下大树，便于后人乘凉</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><blockquote><ul><li>电脑一台，本文以win7为例</li><li>给电脑安装git</li><li>安装node.js</li><li>申请GitHub </li></ul></blockquote><a id="more"></a><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>在我的电脑里面建一个文件夹blog<br>然后进入blog文件夹，右击选择“Git Bash”<br>输入命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pm install -g cnpm --registry=https://registry.npm.taobao.org<span class="comment">#安装npm</span></span><br><span class="line">cnpm install -g hexo-cli</span><br><span class="line">cnpm install hexo --save</span><br><span class="line">hexo -v <span class="comment">#安装完成后，在输入命令，验证是否安装正确</span></span><br></pre></td></tr></table></figure><h2 id="启动hexo"><a href="#启动hexo" class="headerlink" title="启动hexo"></a>启动hexo</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo init <span class="comment">#初始化hexo</span></span><br><span class="line"></span><br><span class="line">cnpm install <span class="comment">#安装生成器</span></span><br><span class="line"></span><br><span class="line">hexo s -g <span class="comment">#运行hexo,以后要在本地运行博客只要输入该命令即可</span></span><br></pre></td></tr></table></figure><p>打开浏览器，输入localhost:4000,就可以在本地看到你的个人博客了<br>停止运行<br>按住Ctrl+C键即可停止</p><h2 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h2><p>使用notepad++编辑器打开blog/_config.yml文件，进行配置<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#博客名称</span></span><br><span class="line">title: 我的博客</span><br><span class="line"><span class="comment">#副标题</span></span><br><span class="line">subtitle: 一天进步一点</span><br><span class="line"><span class="comment">#简介</span></span><br><span class="line">description: 记录生活点滴</span><br><span class="line"><span class="comment">#博客作者</span></span><br><span class="line">author: John Doe</span><br><span class="line"><span class="comment">#博客语言</span></span><br><span class="line">language: zh-CN</span><br><span class="line"><span class="comment">#时区</span></span><br><span class="line">timezone:</span><br><span class="line"><span class="comment">#博客地址,与申请的GitHub一致</span></span><br><span class="line">url: http://elfwalk.github.io</span><br><span class="line">root: /</span><br><span class="line"><span class="comment">#博客链接格式</span></span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line">new_post_name: :title.md <span class="comment"># File name of new posts</span></span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false <span class="comment"># Transform title into titlecase</span></span><br><span class="line">external_link: true <span class="comment"># Open external links in new tab</span></span><br><span class="line">filename_case: <span class="number">0</span></span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: true</span><br><span class="line">  tab_replace:</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"><span class="comment">#日期格式</span></span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"><span class="comment">#分页，每页文章数量</span></span><br><span class="line">per_page: <span class="number">10</span></span><br><span class="line">pagination_dir: page</span><br><span class="line"><span class="comment">#博客主题</span></span><br><span class="line">theme: landscape</span><br><span class="line"><span class="comment">#发布设置</span></span><br><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  <span class="comment">#elfwalk改为你的github用户名</span></span><br><span class="line">  repository: https://github.com/huangchunwu/huangchunwu.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><h2 id="编写文章"><a href="#编写文章" class="headerlink" title="编写文章"></a>编写文章</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"new article"</span></span><br></pre></td></tr></table></figure><p>之后在source/_posts目录下面，多了一个new-article.md的文件<br>打开之后我们会看到：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: new article</span><br><span class="line">date: <span class="number">2014</span><span class="number">-11</span><span class="number">-01</span> <span class="number">20</span>:<span class="number">10</span>:<span class="number">33</span></span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>文件的开头是属性，采用统一的yaml格式，用三条短横线分隔。下面是文章正文。<br>文章的正文支持markdown格式，建议你先学习一下它的语法。markdown不像html似的一大堆标签，很简单，只有几个符号。<br>新建、删除或修改文章后，不需要重启hexo server，刷新一下即可预览。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment"># 删除已经生成的静态页面</span></span><br><span class="line">hexo generate <span class="comment">#生成静态网页</span></span><br><span class="line">hexo deploy <span class="comment">#部署到GitHub</span></span><br><span class="line"></span><br><span class="line">hexo g -d <span class="comment">#也可简写为（一起执行上边两个命令）</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
